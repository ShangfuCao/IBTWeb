{"ast":null,"code":"import { Vector3, Matrix3 } from 'three';\nimport { IfcComponent } from '../../../base-types';\nimport { IfcPlane } from './planes';\nexport class IfcClipper extends IfcComponent {\n  constructor(context) {\n    super(context);\n    this.orthogonalY = true;\n    this.toleranceOrthogonalY = 0.7;\n    this.planeSize = 5;\n\n    this.createPlane = () => {\n      if (!this.enabled) return;\n      const intersects = this.context.castRayIfc();\n      if (!intersects) return;\n      this.createPlaneFromIntersection(intersects);\n      this.intersection = undefined;\n    };\n\n    this.createFromNormalAndCoplanarPoint = (normal, point) => {\n      const plane = new IfcPlane(this.context, point, normal, this.activateDragging, this.deactivateDragging, this.planeSize);\n      this.planes.push(plane);\n      this.context.addClippingPlane(plane.plane);\n      this.updateMaterials();\n    };\n\n    this.deletePlane = plane => {\n      let existingPlane = plane;\n\n      if (!existingPlane) {\n        if (!this.enabled) return;\n        existingPlane = this.pickPlane();\n      }\n\n      if (!existingPlane) return;\n      const index = this.planes.indexOf(existingPlane);\n      if (index === -1) return;\n      existingPlane.removeFromScene();\n      this.planes.splice(index, 1);\n      this.context.removeClippingPlane(existingPlane.plane);\n      this.updateMaterials();\n    };\n\n    this.deleteAllPlanes = () => {\n      this.planes.forEach(plane => {\n        plane.removeFromScene();\n        this.context.removeClippingPlane(plane.plane);\n      });\n      this.planes = [];\n      this.updateMaterials();\n    };\n\n    this.pickPlane = () => {\n      const planeMeshes = this.planes.map(p => p.planeMesh);\n      const arrowMeshes = this.planes.map(p => p.arrowBoundingBox);\n      const intersects = this.context.castRay([...planeMeshes, ...arrowMeshes]);\n\n      if (intersects.length > 0) {\n        return this.planes.find(p => {\n          if (p.planeMesh === intersects[0].object || p.arrowBoundingBox === intersects[0].object) {\n            return p;\n          }\n\n          return null;\n        });\n      }\n\n      return null;\n    };\n\n    this.createPlaneFromIntersection = intersection => {\n      var _a;\n\n      const constant = intersection.point.distanceTo(new Vector3(0, 0, 0));\n      const normal = (_a = intersection.face) === null || _a === void 0 ? void 0 : _a.normal;\n      if (!constant || !normal) return;\n      const normalMatrix = new Matrix3().getNormalMatrix(intersection.object.matrixWorld);\n      const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();\n      this.normalizePlaneDirectionY(worldNormal);\n      const plane = this.newPlane(intersection, worldNormal.negate());\n      this.planes.push(plane);\n      this.context.addClippingPlane(plane.plane);\n      this.updateMaterials();\n    };\n\n    this.activateDragging = () => {\n      this.dragging = true;\n    };\n\n    this.deactivateDragging = () => {\n      this.dragging = false;\n    };\n\n    this.updateMaterials = () => {\n      // Applying clipping to IfcObjects only. This could be improved.\n      this.context.items.ifcModels.forEach(obj => {\n        const mesh = obj;\n        if (mesh.material) this.updateMaterial(mesh);\n        if (mesh.userData.wireframe) this.updateMaterial(mesh.userData.wireframe);\n      });\n    };\n\n    this.context = context;\n    this.enabled = false;\n    this.dragging = false;\n    this.planes = [];\n  }\n\n  get active() {\n    return this.enabled;\n  }\n\n  set active(state) {\n    this.enabled = state;\n    this.planes.forEach(plane => plane.setVisibility(state));\n    this.updateMaterials();\n  }\n\n  normalizePlaneDirectionY(normal) {\n    if (this.orthogonalY) {\n      if (normal.y > this.toleranceOrthogonalY) {\n        normal.x = 0;\n        normal.y = 1;\n        normal.z = 0;\n      }\n\n      if (normal.y < -this.toleranceOrthogonalY) {\n        normal.x = 0;\n        normal.y = -1;\n        normal.z = 0;\n      }\n    }\n  }\n\n  newPlane(intersection, worldNormal) {\n    return new IfcPlane(this.context, intersection.point, worldNormal, this.activateDragging, this.deactivateDragging, this.planeSize);\n  }\n\n  updateMaterial(mesh) {\n    const activePlanes = this.planes.filter(plane => plane.visible);\n\n    if (!Array.isArray(mesh.material)) {\n      mesh.material.clippingPlanes = activePlanes.map(e => e.plane);\n      return;\n    }\n\n    mesh.material.forEach(m => {\n      m.clippingPlanes = activePlanes.map(e => e.plane);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../../src/components/display/clipping-planes/clipper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Vector3, Matrix3 } from 'three';\r\nimport { IfcComponent } from '../../../base-types';\r\nimport { IfcPlane } from './planes';\r\nexport class IfcClipper extends IfcComponent {\r\n    constructor(context) {\r\n        super(context);\r\n        this.orthogonalY = true;\r\n        this.toleranceOrthogonalY = 0.7;\r\n        this.planeSize = 5;\r\n        this.createPlane = () => {\r\n            if (!this.enabled)\r\n                return;\r\n            const intersects = this.context.castRayIfc();\r\n            if (!intersects)\r\n                return;\r\n            this.createPlaneFromIntersection(intersects);\r\n            this.intersection = undefined;\r\n        };\r\n        this.createFromNormalAndCoplanarPoint = (normal, point) => {\r\n            const plane = new IfcPlane(this.context, point, normal, this.activateDragging, this.deactivateDragging, this.planeSize);\r\n            this.planes.push(plane);\r\n            this.context.addClippingPlane(plane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.deletePlane = (plane) => {\r\n            let existingPlane = plane;\r\n            if (!existingPlane) {\r\n                if (!this.enabled)\r\n                    return;\r\n                existingPlane = this.pickPlane();\r\n            }\r\n            if (!existingPlane)\r\n                return;\r\n            const index = this.planes.indexOf(existingPlane);\r\n            if (index === -1)\r\n                return;\r\n            existingPlane.removeFromScene();\r\n            this.planes.splice(index, 1);\r\n            this.context.removeClippingPlane(existingPlane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.deleteAllPlanes = () => {\r\n            this.planes.forEach((plane) => {\r\n                plane.removeFromScene();\r\n                this.context.removeClippingPlane(plane.plane);\r\n            });\r\n            this.planes = [];\r\n            this.updateMaterials();\r\n        };\r\n        this.pickPlane = () => {\r\n            const planeMeshes = this.planes.map((p) => p.planeMesh);\r\n            const arrowMeshes = this.planes.map((p) => p.arrowBoundingBox);\r\n            const intersects = this.context.castRay([...planeMeshes, ...arrowMeshes]);\r\n            if (intersects.length > 0) {\r\n                return this.planes.find((p) => {\r\n                    if (p.planeMesh === intersects[0].object || p.arrowBoundingBox === intersects[0].object) {\r\n                        return p;\r\n                    }\r\n                    return null;\r\n                });\r\n            }\r\n            return null;\r\n        };\r\n        this.createPlaneFromIntersection = (intersection) => {\r\n            var _a;\r\n            const constant = intersection.point.distanceTo(new Vector3(0, 0, 0));\r\n            const normal = (_a = intersection.face) === null || _a === void 0 ? void 0 : _a.normal;\r\n            if (!constant || !normal)\r\n                return;\r\n            const normalMatrix = new Matrix3().getNormalMatrix(intersection.object.matrixWorld);\r\n            const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();\r\n            this.normalizePlaneDirectionY(worldNormal);\r\n            const plane = this.newPlane(intersection, worldNormal.negate());\r\n            this.planes.push(plane);\r\n            this.context.addClippingPlane(plane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.activateDragging = () => {\r\n            this.dragging = true;\r\n        };\r\n        this.deactivateDragging = () => {\r\n            this.dragging = false;\r\n        };\r\n        this.updateMaterials = () => {\r\n            // Applying clipping to IfcObjects only. This could be improved.\r\n            this.context.items.ifcModels.forEach((obj) => {\r\n                const mesh = obj;\r\n                if (mesh.material)\r\n                    this.updateMaterial(mesh);\r\n                if (mesh.userData.wireframe)\r\n                    this.updateMaterial(mesh.userData.wireframe);\r\n            });\r\n        };\r\n        this.context = context;\r\n        this.enabled = false;\r\n        this.dragging = false;\r\n        this.planes = [];\r\n    }\r\n    get active() {\r\n        return this.enabled;\r\n    }\r\n    set active(state) {\r\n        this.enabled = state;\r\n        this.planes.forEach((plane) => plane.setVisibility(state));\r\n        this.updateMaterials();\r\n    }\r\n    normalizePlaneDirectionY(normal) {\r\n        if (this.orthogonalY) {\r\n            if (normal.y > this.toleranceOrthogonalY) {\r\n                normal.x = 0;\r\n                normal.y = 1;\r\n                normal.z = 0;\r\n            }\r\n            if (normal.y < -this.toleranceOrthogonalY) {\r\n                normal.x = 0;\r\n                normal.y = -1;\r\n                normal.z = 0;\r\n            }\r\n        }\r\n    }\r\n    newPlane(intersection, worldNormal) {\r\n        return new IfcPlane(this.context, intersection.point, worldNormal, this.activateDragging, this.deactivateDragging, this.planeSize);\r\n    }\r\n    updateMaterial(mesh) {\r\n        const activePlanes = this.planes.filter((plane) => plane.visible);\r\n        if (!Array.isArray(mesh.material)) {\r\n            mesh.material.clippingPlanes = activePlanes.map((e) => e.plane);\r\n            return;\r\n        }\r\n        mesh.material.forEach((m) => {\r\n            m.clippingPlanes = activePlanes.map((e) => e.plane);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=clipper.js.map"]},"metadata":{},"sourceType":"module"}