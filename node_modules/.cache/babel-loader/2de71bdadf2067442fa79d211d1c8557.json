{"ast":null,"code":"import _toConsumableArray from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Vector3, Matrix3 } from 'three';\nimport { IfcComponent } from '../../../base-types';\nimport { IfcPlane } from './planes';\nexport var IfcClipper = /*#__PURE__*/function (_IfcComponent) {\n  _inherits(IfcClipper, _IfcComponent);\n\n  var _super = _createSuper(IfcClipper);\n\n  function IfcClipper(context) {\n    var _this;\n\n    _classCallCheck(this, IfcClipper);\n\n    _this = _super.call(this, context);\n    _this.orthogonalY = true;\n    _this.toleranceOrthogonalY = 0.7;\n    _this.planeSize = 5;\n\n    _this.createPlane = function () {\n      if (!_this.enabled) return;\n\n      var intersects = _this.context.castRayIfc();\n\n      if (!intersects) return;\n\n      _this.createPlaneFromIntersection(intersects);\n\n      _this.intersection = undefined;\n    };\n\n    _this.createFromNormalAndCoplanarPoint = function (normal, point) {\n      var plane = new IfcPlane(_this.context, point, normal, _this.activateDragging, _this.deactivateDragging, _this.planeSize);\n\n      _this.planes.push(plane);\n\n      _this.context.addClippingPlane(plane.plane);\n\n      _this.updateMaterials();\n    };\n\n    _this.deletePlane = function (plane) {\n      var existingPlane = plane;\n\n      if (!existingPlane) {\n        if (!_this.enabled) return;\n        existingPlane = _this.pickPlane();\n      }\n\n      if (!existingPlane) return;\n\n      var index = _this.planes.indexOf(existingPlane);\n\n      if (index === -1) return;\n      existingPlane.removeFromScene();\n\n      _this.planes.splice(index, 1);\n\n      _this.context.removeClippingPlane(existingPlane.plane);\n\n      _this.updateMaterials();\n    };\n\n    _this.deleteAllPlanes = function () {\n      _this.planes.forEach(function (plane) {\n        plane.removeFromScene();\n\n        _this.context.removeClippingPlane(plane.plane);\n      });\n\n      _this.planes = [];\n\n      _this.updateMaterials();\n    };\n\n    _this.pickPlane = function () {\n      var planeMeshes = _this.planes.map(function (p) {\n        return p.planeMesh;\n      });\n\n      var arrowMeshes = _this.planes.map(function (p) {\n        return p.arrowBoundingBox;\n      });\n\n      var intersects = _this.context.castRay([].concat(_toConsumableArray(planeMeshes), _toConsumableArray(arrowMeshes)));\n\n      if (intersects.length > 0) {\n        return _this.planes.find(function (p) {\n          if (p.planeMesh === intersects[0].object || p.arrowBoundingBox === intersects[0].object) {\n            return p;\n          }\n\n          return null;\n        });\n      }\n\n      return null;\n    };\n\n    _this.createPlaneFromIntersection = function (intersection) {\n      var _a;\n\n      var constant = intersection.point.distanceTo(new Vector3(0, 0, 0));\n      var normal = (_a = intersection.face) === null || _a === void 0 ? void 0 : _a.normal;\n      if (!constant || !normal) return;\n      var normalMatrix = new Matrix3().getNormalMatrix(intersection.object.matrixWorld);\n      var worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();\n\n      _this.normalizePlaneDirectionY(worldNormal);\n\n      var plane = _this.newPlane(intersection, worldNormal.negate());\n\n      _this.planes.push(plane);\n\n      _this.context.addClippingPlane(plane.plane);\n\n      _this.updateMaterials();\n    };\n\n    _this.activateDragging = function () {\n      _this.dragging = true;\n    };\n\n    _this.deactivateDragging = function () {\n      _this.dragging = false;\n    };\n\n    _this.updateMaterials = function () {\n      // Applying clipping to IfcObjects only. This could be improved.\n      _this.context.items.ifcModels.forEach(function (obj) {\n        var mesh = obj;\n        if (mesh.material) _this.updateMaterial(mesh);\n        if (mesh.userData.wireframe) _this.updateMaterial(mesh.userData.wireframe);\n      });\n    };\n\n    _this.context = context;\n    _this.enabled = false;\n    _this.dragging = false;\n    _this.planes = [];\n    return _this;\n  }\n\n  _createClass(IfcClipper, [{\n    key: \"active\",\n    get: function get() {\n      return this.enabled;\n    },\n    set: function set(state) {\n      this.enabled = state;\n      this.planes.forEach(function (plane) {\n        return plane.setVisibility(state);\n      });\n      this.updateMaterials();\n    }\n  }, {\n    key: \"normalizePlaneDirectionY\",\n    value: function normalizePlaneDirectionY(normal) {\n      if (this.orthogonalY) {\n        if (normal.y > this.toleranceOrthogonalY) {\n          normal.x = 0;\n          normal.y = 1;\n          normal.z = 0;\n        }\n\n        if (normal.y < -this.toleranceOrthogonalY) {\n          normal.x = 0;\n          normal.y = -1;\n          normal.z = 0;\n        }\n      }\n    }\n  }, {\n    key: \"newPlane\",\n    value: function newPlane(intersection, worldNormal) {\n      return new IfcPlane(this.context, intersection.point, worldNormal, this.activateDragging, this.deactivateDragging, this.planeSize);\n    }\n  }, {\n    key: \"updateMaterial\",\n    value: function updateMaterial(mesh) {\n      var activePlanes = this.planes.filter(function (plane) {\n        return plane.visible;\n      });\n\n      if (!Array.isArray(mesh.material)) {\n        mesh.material.clippingPlanes = activePlanes.map(function (e) {\n          return e.plane;\n        });\n        return;\n      }\n\n      mesh.material.forEach(function (m) {\n        m.clippingPlanes = activePlanes.map(function (e) {\n          return e.plane;\n        });\n      });\n    }\n  }]);\n\n  return IfcClipper;\n}(IfcComponent);","map":{"version":3,"sources":["../../../../src/components/display/clipping-planes/clipper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Vector3, Matrix3 } from 'three';\r\nimport { IfcComponent } from '../../../base-types';\r\nimport { IfcPlane } from './planes';\r\nexport class IfcClipper extends IfcComponent {\r\n    constructor(context) {\r\n        super(context);\r\n        this.orthogonalY = true;\r\n        this.toleranceOrthogonalY = 0.7;\r\n        this.planeSize = 5;\r\n        this.createPlane = () => {\r\n            if (!this.enabled)\r\n                return;\r\n            const intersects = this.context.castRayIfc();\r\n            if (!intersects)\r\n                return;\r\n            this.createPlaneFromIntersection(intersects);\r\n            this.intersection = undefined;\r\n        };\r\n        this.createFromNormalAndCoplanarPoint = (normal, point) => {\r\n            const plane = new IfcPlane(this.context, point, normal, this.activateDragging, this.deactivateDragging, this.planeSize);\r\n            this.planes.push(plane);\r\n            this.context.addClippingPlane(plane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.deletePlane = (plane) => {\r\n            let existingPlane = plane;\r\n            if (!existingPlane) {\r\n                if (!this.enabled)\r\n                    return;\r\n                existingPlane = this.pickPlane();\r\n            }\r\n            if (!existingPlane)\r\n                return;\r\n            const index = this.planes.indexOf(existingPlane);\r\n            if (index === -1)\r\n                return;\r\n            existingPlane.removeFromScene();\r\n            this.planes.splice(index, 1);\r\n            this.context.removeClippingPlane(existingPlane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.deleteAllPlanes = () => {\r\n            this.planes.forEach((plane) => {\r\n                plane.removeFromScene();\r\n                this.context.removeClippingPlane(plane.plane);\r\n            });\r\n            this.planes = [];\r\n            this.updateMaterials();\r\n        };\r\n        this.pickPlane = () => {\r\n            const planeMeshes = this.planes.map((p) => p.planeMesh);\r\n            const arrowMeshes = this.planes.map((p) => p.arrowBoundingBox);\r\n            const intersects = this.context.castRay([...planeMeshes, ...arrowMeshes]);\r\n            if (intersects.length > 0) {\r\n                return this.planes.find((p) => {\r\n                    if (p.planeMesh === intersects[0].object || p.arrowBoundingBox === intersects[0].object) {\r\n                        return p;\r\n                    }\r\n                    return null;\r\n                });\r\n            }\r\n            return null;\r\n        };\r\n        this.createPlaneFromIntersection = (intersection) => {\r\n            var _a;\r\n            const constant = intersection.point.distanceTo(new Vector3(0, 0, 0));\r\n            const normal = (_a = intersection.face) === null || _a === void 0 ? void 0 : _a.normal;\r\n            if (!constant || !normal)\r\n                return;\r\n            const normalMatrix = new Matrix3().getNormalMatrix(intersection.object.matrixWorld);\r\n            const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();\r\n            this.normalizePlaneDirectionY(worldNormal);\r\n            const plane = this.newPlane(intersection, worldNormal.negate());\r\n            this.planes.push(plane);\r\n            this.context.addClippingPlane(plane.plane);\r\n            this.updateMaterials();\r\n        };\r\n        this.activateDragging = () => {\r\n            this.dragging = true;\r\n        };\r\n        this.deactivateDragging = () => {\r\n            this.dragging = false;\r\n        };\r\n        this.updateMaterials = () => {\r\n            // Applying clipping to IfcObjects only. This could be improved.\r\n            this.context.items.ifcModels.forEach((obj) => {\r\n                const mesh = obj;\r\n                if (mesh.material)\r\n                    this.updateMaterial(mesh);\r\n                if (mesh.userData.wireframe)\r\n                    this.updateMaterial(mesh.userData.wireframe);\r\n            });\r\n        };\r\n        this.context = context;\r\n        this.enabled = false;\r\n        this.dragging = false;\r\n        this.planes = [];\r\n    }\r\n    get active() {\r\n        return this.enabled;\r\n    }\r\n    set active(state) {\r\n        this.enabled = state;\r\n        this.planes.forEach((plane) => plane.setVisibility(state));\r\n        this.updateMaterials();\r\n    }\r\n    normalizePlaneDirectionY(normal) {\r\n        if (this.orthogonalY) {\r\n            if (normal.y > this.toleranceOrthogonalY) {\r\n                normal.x = 0;\r\n                normal.y = 1;\r\n                normal.z = 0;\r\n            }\r\n            if (normal.y < -this.toleranceOrthogonalY) {\r\n                normal.x = 0;\r\n                normal.y = -1;\r\n                normal.z = 0;\r\n            }\r\n        }\r\n    }\r\n    newPlane(intersection, worldNormal) {\r\n        return new IfcPlane(this.context, intersection.point, worldNormal, this.activateDragging, this.deactivateDragging, this.planeSize);\r\n    }\r\n    updateMaterial(mesh) {\r\n        const activePlanes = this.planes.filter((plane) => plane.visible);\r\n        if (!Array.isArray(mesh.material)) {\r\n            mesh.material.clippingPlanes = activePlanes.map((e) => e.plane);\r\n            return;\r\n        }\r\n        mesh.material.forEach((m) => {\r\n            m.clippingPlanes = activePlanes.map((e) => e.plane);\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=clipper.js.map"]},"metadata":{},"sourceType":"module"}