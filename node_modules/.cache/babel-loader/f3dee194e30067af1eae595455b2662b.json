{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Topic = exports.BcfReader = void 0;\n\nconst Helpers_1 = require(\"./Helpers\");\n\nconst unzipit_1 = require(\"unzipit\");\n\nclass BcfReader {\n  constructor() {\n    this.topics = [];\n\n    this.read = src => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const topics = [];\n        this.bcf_archive = yield unzipit_1.unzip(src);\n        const {\n          entries\n        } = this.bcf_archive;\n\n        for (const [name, entry] of Object.entries(entries)) {\n          if (name.endsWith('.bcf')) {\n            topics.push(entry);\n          }\n        }\n\n        for (let i = 0; i < topics.length; i++) {\n          const t = topics[i];\n          const topic = new Topic(this, t);\n          yield topic.read();\n          this.topics.push(topic);\n        }\n      } catch (e) {\n        console.log(\"Error in loading BCF archive. The error below was thrown.\");\n        console.error(e);\n      }\n    });\n\n    this.getEntry = name => {\n      var _a;\n\n      return (_a = this.bcf_archive) === null || _a === void 0 ? void 0 : _a.entries[name];\n    };\n  }\n\n}\n\nexports.BcfReader = BcfReader;\n\nclass Topic {\n  constructor(reader, markup) {\n    this.viewpoints = [];\n\n    this.read = () => __awaiter(this, void 0, void 0, function* () {\n      yield this.parseMarkup();\n      yield this.parseViewpoints();\n    });\n\n    this.parseMarkup = () => __awaiter(this, void 0, void 0, function* () {\n      this.markup = Helpers_1.Helpers.GetMarkup(yield this.markup_file.text());\n    });\n\n    this.parseViewpoints = () => __awaiter(this, void 0, void 0, function* () {\n      if (!this.markup) return;\n\n      if (this.markup.viewpoints) {\n        const viewpoints = this.markup.viewpoints;\n\n        for (let i = 0; i < viewpoints.length; i++) {\n          const entry = viewpoints[i];\n          const key = this.markup.topic.guid + \"/\" + entry.viewpoint;\n          const file = this.reader.getEntry(key);\n          if (!file) throw new Error(\"Missing Visualization Info\");\n          const viewpoint = Helpers_1.Helpers.GetViewpoint(yield file.text());\n          this.viewpoints.push(viewpoint); // Helpers.WriteJsonToFile(`./output/${name}/${id}/${entry.viewpoint}.json`, viewpoint);\n        }\n      }\n    });\n\n    this.getViewpointSnapshot = viewpoint => __awaiter(this, void 0, void 0, function* () {\n      if (!viewpoint || !this.markup) return;\n      const entry = this.reader.getEntry(`${this.markup.topic.guid}/${viewpoint.snapshot}`);\n\n      if (entry) {\n        return yield entry.blob();\n      }\n    });\n\n    this.reader = reader;\n    this.markup_file = markup;\n  }\n\n}\n\nexports.Topic = Topic;","map":{"version":3,"sources":["../src/BcfReader.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Topic = exports.BcfReader = void 0;\r\nconst Helpers_1 = require(\"./Helpers\");\r\nconst unzipit_1 = require(\"unzipit\");\r\nclass BcfReader {\r\n    constructor() {\r\n        this.topics = [];\r\n        this.read = (src) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const topics = [];\r\n                this.bcf_archive = yield unzipit_1.unzip(src);\r\n                const { entries } = this.bcf_archive;\r\n                for (const [name, entry] of Object.entries(entries)) {\r\n                    if (name.endsWith('.bcf')) {\r\n                        topics.push(entry);\r\n                    }\r\n                }\r\n                for (let i = 0; i < topics.length; i++) {\r\n                    const t = topics[i];\r\n                    const topic = new Topic(this, t);\r\n                    yield topic.read();\r\n                    this.topics.push(topic);\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.log(\"Error in loading BCF archive. The error below was thrown.\");\r\n                console.error(e);\r\n            }\r\n        });\r\n        this.getEntry = (name) => {\r\n            var _a;\r\n            return (_a = this.bcf_archive) === null || _a === void 0 ? void 0 : _a.entries[name];\r\n        };\r\n    }\r\n}\r\nexports.BcfReader = BcfReader;\r\nclass Topic {\r\n    constructor(reader, markup) {\r\n        this.viewpoints = [];\r\n        this.read = () => __awaiter(this, void 0, void 0, function* () {\r\n            yield this.parseMarkup();\r\n            yield this.parseViewpoints();\r\n        });\r\n        this.parseMarkup = () => __awaiter(this, void 0, void 0, function* () {\r\n            this.markup = Helpers_1.Helpers.GetMarkup(yield this.markup_file.text());\r\n        });\r\n        this.parseViewpoints = () => __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.markup)\r\n                return;\r\n            if (this.markup.viewpoints) {\r\n                const viewpoints = this.markup.viewpoints;\r\n                for (let i = 0; i < viewpoints.length; i++) {\r\n                    const entry = viewpoints[i];\r\n                    const key = this.markup.topic.guid + \"/\" + entry.viewpoint;\r\n                    const file = this.reader.getEntry(key);\r\n                    if (!file)\r\n                        throw new Error(\"Missing Visualization Info\");\r\n                    const viewpoint = Helpers_1.Helpers.GetViewpoint(yield file.text());\r\n                    this.viewpoints.push(viewpoint);\r\n                    // Helpers.WriteJsonToFile(`./output/${name}/${id}/${entry.viewpoint}.json`, viewpoint);\r\n                }\r\n            }\r\n        });\r\n        this.getViewpointSnapshot = (viewpoint) => __awaiter(this, void 0, void 0, function* () {\r\n            if (!viewpoint || !this.markup)\r\n                return;\r\n            const entry = this.reader.getEntry(`${this.markup.topic.guid}/${viewpoint.snapshot}`);\r\n            if (entry) {\r\n                return yield entry.blob();\r\n            }\r\n        });\r\n        this.reader = reader;\r\n        this.markup_file = markup;\r\n    }\r\n}\r\nexports.Topic = Topic;\r\n//# sourceMappingURL=BcfReader.js.map"]},"metadata":{},"sourceType":"script"}