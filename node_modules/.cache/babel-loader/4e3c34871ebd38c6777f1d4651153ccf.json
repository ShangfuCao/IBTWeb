{"ast":null,"code":"/* unzipit@1.3.3, license MIT */\n\n/* global SharedArrayBuffer, process */\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode = typeof process !== 'undefined' && process.versions && typeof process.versions.node !== 'undefined' && typeof process.versions.electron === 'undefined';\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView) ? new Uint8Array(arrayBufferOrView) : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n\n  async getLength() {\n    return this.blob.size;\n  }\n\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n\n  async sliceAsBlob(offset, length) {\n    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.blob.slice(offset, offset + length, type);\n  }\n\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, {\n        method: 'HEAD'\n      });\n\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n\n      this.length = parseInt(req.headers.get('content-length'));\n\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n\n    return this.length;\n  }\n\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`\n      }\n    });\n\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n\n}\n\nfunction inflate(data, buf) {\n  var u8 = Uint8Array;\n  if (data[0] == 3 && data[1] == 0) return buf ? buf : new u8(0);\n  var bitsF = _bitsF,\n      bitsE = _bitsE,\n      decodeTiny = _decodeTiny,\n      get17 = _get17;\n  var noBuf = buf == null;\n  if (noBuf) buf = new u8(data.length >>> 2 << 3);\n  var BFINAL = 0,\n      BTYPE = 0,\n      HLIT = 0,\n      HDIST = 0,\n      HCLEN = 0,\n      ML = 0,\n      MD = 0;\n  var off = 0,\n      pos = 0;\n  var lmap, dmap;\n\n  while (BFINAL == 0) {\n    BFINAL = bitsF(data, pos, 1);\n    BTYPE = bitsF(data, pos + 1, 2);\n    pos += 3; //console.log(BFINAL, BTYPE);\n\n    if (BTYPE == 0) {\n      if ((pos & 7) != 0) pos += 8 - (pos & 7);\n      var p8 = (pos >>> 3) + 4,\n          len = data[p8 - 4] | data[p8 - 3] << 8; //console.log(len);//bitsF(data, pos, 16), \n\n      if (noBuf) buf = _check(buf, off + len);\n      buf.set(new u8(data.buffer, data.byteOffset + p8, len), off); //for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n      //for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\n      pos = p8 + len << 3;\n      off += len;\n      continue;\n    }\n\n    if (noBuf) buf = _check(buf, off + (1 << 17)); // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\n    if (BTYPE == 1) {\n      lmap = U.flmap;\n      dmap = U.fdmap;\n      ML = (1 << 9) - 1;\n      MD = (1 << 5) - 1;\n    }\n\n    if (BTYPE == 2) {\n      HLIT = bitsE(data, pos, 5) + 257;\n      HDIST = bitsE(data, pos + 5, 5) + 1;\n      HCLEN = bitsE(data, pos + 10, 4) + 4;\n      pos += 14;\n\n      for (var i = 0; i < 38; i += 2) {\n        U.itree[i] = 0;\n        U.itree[i + 1] = 0;\n      }\n\n      var tl = 1;\n\n      for (var i = 0; i < HCLEN; i++) {\n        var l = bitsE(data, pos + i * 3, 3);\n        U.itree[(U.ordr[i] << 1) + 1] = l;\n        if (l > tl) tl = l;\n      }\n\n      pos += 3 * HCLEN; //console.log(itree);\n\n      makeCodes(U.itree, tl);\n      codes2map(U.itree, tl, U.imap);\n      lmap = U.lmap;\n      dmap = U.dmap;\n      pos = decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);\n\n      var mx0 = _copyOut(U.ttree, 0, HLIT, U.ltree);\n\n      ML = (1 << mx0) - 1;\n\n      var mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);\n\n      MD = (1 << mx1) - 1; //var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\n      makeCodes(U.ltree, mx0);\n      codes2map(U.ltree, mx0, lmap); //var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\n      makeCodes(U.dtree, mx1);\n      codes2map(U.dtree, mx1, dmap);\n    } //var ooff=off, opos=pos;\n\n\n    while (true) {\n      var code = lmap[get17(data, pos) & ML];\n      pos += code & 15;\n      var lit = code >>> 4; //U.lhst[lit]++;  \n\n      if (lit >>> 8 == 0) {\n        buf[off++] = lit;\n      } else if (lit == 256) {\n        break;\n      } else {\n        var end = off + lit - 254;\n\n        if (lit > 264) {\n          var ebs = U.ldef[lit - 257];\n          end = off + (ebs >>> 3) + bitsE(data, pos, ebs & 7);\n          pos += ebs & 7;\n        } //dst[end-off]++;\n\n\n        var dcode = dmap[get17(data, pos) & MD];\n        pos += dcode & 15;\n        var dlit = dcode >>> 4;\n        var dbs = U.ddef[dlit],\n            dst = (dbs >>> 4) + bitsF(data, pos, dbs & 15);\n        pos += dbs & 15; //var o0 = off-dst, stp = Math.min(end-off, dst);\n        //if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n        //if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n        //if(dst==1) buf.fill(buf[off-1], off, end);  else\n\n        if (noBuf) buf = _check(buf, off + (1 << 17));\n\n        while (off < end) {\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n        }\n\n        off = end; //while(off!=end) {  buf[off]=buf[off++-dst];  }\n      }\n    } //console.log(off-ooff, (pos-opos)>>>3);\n\n  } //console.log(dst);\n  //console.log(tlen, dlen, off-tlen+tcnt);\n\n\n  return buf.length == off ? buf : buf.slice(0, off);\n}\n\nfunction _check(buf, len) {\n  var bl = buf.length;\n  if (len <= bl) return buf;\n  var nbuf = new Uint8Array(Math.max(bl << 1, len));\n  nbuf.set(buf, 0); //for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\n  return nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n  var bitsE = _bitsE,\n      get17 = _get17;\n  var i = 0;\n\n  while (i < len) {\n    var code = lmap[get17(data, pos) & LL];\n    pos += code & 15;\n    var lit = code >>> 4;\n\n    if (lit <= 15) {\n      tree[i] = lit;\n      i++;\n    } else {\n      var ll = 0,\n          n = 0;\n\n      if (lit == 16) {\n        n = 3 + bitsE(data, pos, 2);\n        pos += 2;\n        ll = tree[i - 1];\n      } else if (lit == 17) {\n        n = 3 + bitsE(data, pos, 3);\n        pos += 3;\n      } else if (lit == 18) {\n        n = 11 + bitsE(data, pos, 7);\n        pos += 7;\n      }\n\n      var ni = i + n;\n\n      while (i < ni) {\n        tree[i] = ll;\n        i++;\n      }\n    }\n  }\n\n  return pos;\n}\n\nfunction _copyOut(src, off, len, tree) {\n  var mx = 0,\n      i = 0,\n      tl = tree.length >>> 1;\n\n  while (i < len) {\n    var v = src[i + off];\n    tree[i << 1] = 0;\n    tree[(i << 1) + 1] = v;\n    if (v > mx) mx = v;\n    i++;\n  }\n\n  while (i < tl) {\n    tree[i << 1] = 0;\n    tree[(i << 1) + 1] = 0;\n    i++;\n  }\n\n  return mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {\n  // code, length\n  var max_code = tree.length;\n  var code, bits, n, i, len;\n  var bl_count = U.bl_count;\n\n  for (var i = 0; i <= MAX_BITS; i++) bl_count[i] = 0;\n\n  for (i = 1; i < max_code; i += 2) bl_count[tree[i]]++;\n\n  var next_code = U.next_code; // smallest code for each length\n\n  code = 0;\n  bl_count[0] = 0;\n\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    code = code + bl_count[bits - 1] << 1;\n    next_code[bits] = code;\n  }\n\n  for (n = 0; n < max_code; n += 2) {\n    len = tree[n + 1];\n\n    if (len != 0) {\n      tree[n] = next_code[len];\n      next_code[len]++;\n    }\n  }\n}\n\nfunction codes2map(tree, MAX_BITS, map) {\n  var max_code = tree.length;\n  var r15 = U.rev15;\n\n  for (var i = 0; i < max_code; i += 2) if (tree[i + 1] != 0) {\n    var lit = i >> 1;\n    var cl = tree[i + 1],\n        val = lit << 4 | cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\n    var rest = MAX_BITS - cl,\n        i0 = tree[i] << rest,\n        i1 = i0 + (1 << rest); //tree[i]=r15[i0]>>>(15-MAX_BITS);\n\n    while (i0 != i1) {\n      var p0 = r15[i0] >>> 15 - MAX_BITS;\n      map[p0] = val;\n      i0++;\n    }\n  }\n}\n\nfunction revCodes(tree, MAX_BITS) {\n  var r15 = U.rev15,\n      imb = 15 - MAX_BITS;\n\n  for (var i = 0; i < tree.length; i += 2) {\n    var i0 = tree[i] << MAX_BITS - tree[i + 1];\n    tree[i] = r15[i0] >>> imb;\n  }\n}\n\nfunction _bitsE(dt, pos, length) {\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;\n}\n\nfunction _bitsF(dt, pos, length) {\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;\n}\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\n\n\nfunction _get17(dt, pos) {\n  // return at least 17 meaningful bytes\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7);\n}\n\nconst U = function () {\n  var u16 = Uint16Array,\n      u32 = Uint32Array;\n  return {\n    next_code: new u16(16),\n    bl_count: new u16(16),\n    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n    ldef: new u16(32),\n    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n    ddef: new u32(32),\n    flmap: new u16(512),\n    fltree: [],\n    fdmap: new u16(32),\n    fdtree: [],\n    lmap: new u16(32768),\n    ltree: [],\n    ttree: [],\n    dmap: new u16(32768),\n    dtree: [],\n    imap: new u16(512),\n    itree: [],\n    //rev9 : new u16(  512)\n    rev15: new u16(1 << 15),\n    lhst: new u32(286),\n    dhst: new u32(30),\n    ihst: new u32(19),\n    lits: new u32(15000),\n    strt: new u16(1 << 16),\n    prev: new u16(1 << 15)\n  };\n}();\n\n(function () {\n  var len = 1 << 15;\n\n  for (var i = 0; i < len; i++) {\n    var x = i;\n    x = (x & 0xaaaaaaaa) >>> 1 | (x & 0x55555555) << 1;\n    x = (x & 0xcccccccc) >>> 2 | (x & 0x33333333) << 2;\n    x = (x & 0xf0f0f0f0) >>> 4 | (x & 0x0f0f0f0f) << 4;\n    x = (x & 0xff00ff00) >>> 8 | (x & 0x00ff00ff) << 8;\n    U.rev15[i] = (x >>> 16 | x << 16) >>> 17;\n  }\n\n  function pushV(tgt, n, sv) {\n    while (n-- != 0) tgt.push(0, sv);\n  }\n\n  for (var i = 0; i < 32; i++) {\n    U.ldef[i] = U.of0[i] << 3 | U.exb[i];\n    U.ddef[i] = U.df0[i] << 4 | U.dxb[i];\n  }\n\n  pushV(U.fltree, 144, 8);\n  pushV(U.fltree, 255 - 143, 9);\n  pushV(U.fltree, 279 - 255, 7);\n  pushV(U.fltree, 287 - 279, 8);\n  /*\n  var i = 0;\n  for(; i<=143; i++) U.fltree.push(0,8);\n  for(; i<=255; i++) U.fltree.push(0,9);\n  for(; i<=279; i++) U.fltree.push(0,7);\n  for(; i<=287; i++) U.fltree.push(0,8);\n  */\n\n  makeCodes(U.fltree, 9);\n  codes2map(U.fltree, 9, U.flmap);\n  revCodes(U.fltree, 9);\n  pushV(U.fdtree, 32, 5); //for(i=0;i<32; i++) U.fdtree.push(0,5);\n\n  makeCodes(U.fdtree, 5);\n  codes2map(U.fdtree, 5, U.fdmap);\n  revCodes(U.fdtree, 5);\n  pushV(U.itree, 19, 0);\n  pushV(U.ltree, 286, 0);\n  pushV(U.dtree, 30, 0);\n  pushV(U.ttree, 320, 0);\n  /*\n  for(var i=0; i< 19; i++) U.itree.push(0,0);\n  for(var i=0; i<286; i++) U.ltree.push(0,0);\n  for(var i=0; i< 30; i++) U.dtree.push(0,0);\n  for(var i=0; i<320; i++) U.ttree.push(0,0);\n  */\n})();\n\nconst crc = {\n  table: function () {\n    var tab = new Uint32Array(256);\n\n    for (var n = 0; n < 256; n++) {\n      var c = n;\n\n      for (var k = 0; k < 8; k++) {\n        if (c & 1) c = 0xedb88320 ^ c >>> 1;else c = c >>> 1;\n      }\n\n      tab[n] = c;\n    }\n\n    return tab;\n  }(),\n  update: function (c, buf, off, len) {\n    for (var i = 0; i < len; i++) c = crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;\n\n    return c;\n  },\n  crc: function (b, o, l) {\n    return crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\n  }\n};\n\nfunction inflateRaw(file, buf) {\n  return inflate(file, buf);\n}\n/* global module */\n\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false\n};\nlet nextId = 0; // Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\n\nlet numWorkers = 0;\nlet canUseWorkers = true; // gets set to false if we can't start a worker\n\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {\n    id,\n    error,\n    data\n  } = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n} // Because Firefox uses non-standard onerror to signal an error.\n\n\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n\n    worker.onmessage = e => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\nconst workerHelper = function () {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {\n      Worker\n    } = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n\n      addEventListener(worker, fn) {\n        worker.on('message', data => {\n          fn({\n            target: worker,\n            data\n          });\n        });\n      },\n\n      async terminate(worker) {\n        await worker.terminate();\n      }\n\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so ¯\\_(ツ)_/¯\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n\n        try {\n          const req = await fetch(url, {\n            mode: 'cors'\n          });\n\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {\n            type: 'application/javascript'\n          }));\n          const worker = await startWorker(url);\n          config.workerURL = url; // this is a hack. What's a better way to structure this code?\n\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n\n      async terminate(worker) {\n        worker.terminate();\n      }\n\n    };\n  }\n}();\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers; // see comment at numWorkers declaration\n\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n\n  return availableWorkers.pop();\n} // @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\n\n\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type ? new Blob([dst], {\n    type\n  }) : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker(); // canUseWorkers might have been set out-of-band (need refactor)\n\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n\n        const {\n          id,\n          src,\n          uncompressedSize,\n          type,\n          resolve,\n          reject\n        } = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {\n          id,\n          resolve,\n          reject\n        });\n        const transferables = []; // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize\n          }\n        }, transferables);\n      }\n\n      return;\n    }\n  } // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n\n\n  while (waitingForWorkerQueue.length) {\n    const {\n      src,\n      uncompressedSize,\n      type,\n      resolve\n    } = waitingForWorkerQueue.shift();\n    let data = src;\n\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL; // there's no reason to set the workerURL if you're not going to use workers\n\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n} // It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\n\n\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({\n      src,\n      uncompressedSize,\n      type,\n      resolve,\n      reject,\n      id: nextId++\n    });\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n\n  const minute = time >> 5 & 0x3f; // 0-59\n\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n  } // returns a promise that returns a Blob for this entry\n\n\n  async blob() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'application/octet-stream';\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  } // returns a promise that returns an ArrayBuffer for this entry\n\n\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  } // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n\n\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  } // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n\n\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\n\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n} // The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\n\n\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  }\n\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset] + uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset] + uint8View[offset + 1] * 0x100 + uint8View[offset + 2] * 0x10000 + uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) + getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n\n/* eslint-enable no-irregular-whitespace */\n\n\nconst utf8Decoder = new TextDecoder();\n\nfunction decodeBuffer(uint8View, isUTF8) {\n  /* eslint-disable-line no-unused-vars */\n\n  /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    } // 0 - End of central directory signature\n\n\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i); // 4 - Number of this disk\n\n    const diskNumber = getUint16LE(eocdr, 4);\n\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    } // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n\n\n    const entryCount = getUint16LE(eocdr, 10); // 12 - Size of central directory (bytes)\n\n    const centralDirectorySize = getUint32LE(eocdr, 12); // 16 - Offset of start of central directory, relative to start of archive\n\n    const centralDirectoryOffset = getUint32LE(eocdr, 16); // 20 - Comment length\n\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    } // 22 - Comment\n    // the encoding is always cp437.\n\n\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20); // 0 - zip64 end of central dir locator signature\n\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  } // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n\n\n  const zip64EocdrOffset = getUint64LE(eocdl, 8); // 16 - total number of disks\n  // ZIP64 end of central directory record\n\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56); // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  } // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n\n\n  const entryCount = getUint64LE(zip64Eocdr, 32); // 40 - size of the central directory                               8 bytes\n\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40); // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48); // 56 - zip64 extensible data sector                                (variable size)\n\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46); // 0 - Central directory file header signature\n\n    const signature = getUint32LE(buffer, 0);\n\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42)\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes); // 46+n - Extra field\n\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd)\n      });\n      i = dataEnd;\n    } // 46+n+m - File comment\n\n\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize === 0xffffffff || rawEntry.compressedSize === 0xffffffff || rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n\n      if (!zip64ExtraField) {\n        return new Error('expected zip64 extended information extra field');\n      }\n\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0; // 0 - Original Size          8 bytes\n\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      } // 8 - Compressed Size        8 bytes\n\n\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      } // 16 - Relative Header Offset 8 bytes\n\n\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      } // 24 - Disk Start Number      4 bytes\n\n    } // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n\n\n    const nameField = rawEntry.extraFields.find(e => e.id === 0x7075 && e.data.length >= 6 && // too short to be meaningful\n    e.data[0] === 1 && // Version       1 byte      version of this extra field, currently 1\n    getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n    // > If the CRC check fails, this UTF-8 Path Extra Field should be\n    // > ignored and the File Name field in the header should be used instead.\n\n    if (nameField) {\n      // UnicodeName Variable UTF-8 version of the entry File Name\n      rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    } // validate file size\n\n\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n\n    rawEntries.push(rawEntry);\n  }\n\n  const zip = {\n    comment,\n    commentBytes\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e))\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30); // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n\n  const totalLength = await reader.getLength(); // 0 - Local file header signature = 0x04034b50\n\n  const signature = getUint32LE(buffer, 0);\n\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  } // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n\n\n  const fileNameLength = getUint16LE(buffer, 26); // 28 - Extra field length (m)\n\n  const extraFieldLength = getUint16LE(buffer, 28); // 30 - File name\n  // 30+n - Extra field\n\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n\n  return {\n    decompress,\n    fileDataStart\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {\n    decompress,\n    fileDataStart\n  } = await readEntryDataHeader(reader, rawEntry);\n\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize); // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  } // see comment in readEntryDateAsBlob\n\n\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {\n    decompress,\n    fileDataStart\n  } = await readEntryDataHeader(reader, rawEntry);\n\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {\n      type\n    });\n  } // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n\n\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || source && source.buffer && source.buffer instanceof ArrayBuffer) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n} // If the names are not utf8 you should use unzipitRaw\n\n\nasync function unzip(source) {\n  const {\n    zip,\n    entries\n  } = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v]))\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };","map":{"version":3,"sources":["/Users/shangfualexcao/Desktop/examples-1/simple-react/node_modules/unzipit/dist/unzipit.module.js"],"names":["readBlobAsArrayBuffer","blob","arrayBuffer","Promise","resolve","reject","reader","FileReader","addEventListener","result","readAsArrayBuffer","readBlobAsUint8Array","Uint8Array","isBlob","v","Blob","isSharedArrayBuffer","b","SharedArrayBuffer","isNode","process","versions","node","electron","isTypedArraySameAsArrayBuffer","typedArray","byteOffset","byteLength","buffer","ArrayBufferReader","constructor","arrayBufferOrView","ArrayBuffer","getLength","read","offset","length","BlobReader","size","slice","sliceAsBlob","type","HTTPRangeReader","url","undefined","req","fetch","method","ok","Error","status","statusText","parseInt","headers","get","Number","isNaN","Range","inflate","data","buf","u8","bitsF","_bitsF","bitsE","_bitsE","decodeTiny","_decodeTiny","get17","_get17","noBuf","BFINAL","BTYPE","HLIT","HDIST","HCLEN","ML","MD","off","pos","lmap","dmap","p8","len","_check","set","U","flmap","fdmap","i","itree","tl","l","ordr","makeCodes","codes2map","imap","ttree","mx0","_copyOut","ltree","mx1","dtree","code","lit","end","ebs","ldef","dcode","dlit","dbs","ddef","dst","bl","nbuf","Math","max","LL","tree","ll","n","ni","src","mx","MAX_BITS","max_code","bits","bl_count","next_code","map","r15","rev15","cl","val","rest","i0","i1","p0","revCodes","imb","dt","u16","Uint16Array","u32","Uint32Array","of0","exb","df0","dxb","fltree","fdtree","lhst","dhst","ihst","lits","strt","prev","x","pushV","tgt","sv","push","crc","table","tab","c","k","update","o","inflateRaw","file","config","numWorkers","workerURL","useWorkers","nextId","canUseWorkers","workers","availableWorkers","waitingForWorkerQueue","currentlyProcessingIdToRequestMap","Map","handleResult","e","makeWorkerAvailable","target","id","error","request","delete","startWorker","worker","Worker","onmessage","onerror","dynamicRequire","mod","require","workerHelper","module","createWorker","fn","on","terminate","console","warn","text","mode","URL","createObjectURL","btoa","processWaitingForWorkerQueue","getAvailableWorker","pop","inflateRawLocal","uncompressedSize","shift","transferables","postMessage","setOptions","options","inflateRawAsync","clearArray","arr","splice","cleanup","clear","dosDateTimeToDate","date","time","day","month","year","millisecond","second","minute","hour","Date","ZipEntry","rawEntry","_reader","_rawEntry","name","nameBytes","compressedSize","comment","commentBytes","compressionMethod","lastModDate","lastModFileDate","lastModFileTime","isDirectory","endsWith","encrypted","generalPurposeBitFlag","readEntryDataAsBlob","readEntryDataAsArrayBuffer","decodeBuffer","json","JSON","parse","EOCDR_WITHOUT_COMMENT_SIZE","MAX_COMMENT_SIZE","EOCDR_SIGNATURE","ZIP64_EOCDR_SIGNATURE","readAs","readAsBlobOrTypedArray","crc$1","unsigned","getUint16LE","uint8View","getUint32LE","getUint64LE","utf8Decoder","TextDecoder","isUTF8","decode","findEndOfCentralDirector","totalLength","min","readStart","eocdr","diskNumber","entryCount","centralDirectorySize","centralDirectoryOffset","commentLength","expectedCommentLength","readZip64CentralDirectory","readEntries","END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE","zip64EocdlOffset","eocdl","zip64EocdrOffset","zip64Eocdr","CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE","rawEntryCount","readEntryCursor","allEntriesBuffer","rawEntries","subarray","signature","toString","versionMadeBy","versionNeededToExtract","crc32","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","externalFileAttributes","relativeOffsetOfLocalHeader","fileCommentStart","extraFieldBuffer","extraFields","headerId","dataSize","dataStart","dataEnd","zip64ExtraField","find","zip64EiefBuffer","index","nameField","fileName","expectedCompressedSize","zip","entries","readEntryDataHeader","localFileHeaderEnd","decompress","fileDataStart","fileDataEnd","dataView","typedArrayOrBlob","setOptions$1","unzipRaw","source","MAX_SAFE_INTEGER","unzip","Object","fromEntries","cleanup$1"],"mappings":"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","sourcesContent":["/* unzipit@1.3.3, license MIT */\n/* global SharedArrayBuffer, process */\n\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode =\n    (typeof process !== 'undefined') &&\n    process.versions &&\n    (typeof process.versions.node !== 'undefined') &&\n    (typeof process.versions.electron === 'undefined');\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = (arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView))\n       ? new Uint8Array(arrayBufferOrView)\n       : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n  async getLength() {\n    return this.blob.size;\n  }\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n  async sliceAsBlob(offset, length, type = '') {\n    return this.blob.slice(offset, offset + length, type);\n  }\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, { method: 'HEAD' });\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n      this.length = parseInt(req.headers.get('content-length'));\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n    return this.length;\n  }\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`,\n      },\n    });\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n}\n\nfunction inflate(data, buf) {\n\tvar u8=Uint8Array;\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\n\tvar bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;\n\t\n\tvar noBuf = (buf==null);\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\n\t\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\n\tvar off = 0, pos = 0;\n\tvar lmap, dmap;\n\t\n\twhile(BFINAL==0) {\t\t\n\t\tBFINAL = bitsF(data, pos  , 1);\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\n\t\t//console.log(BFINAL, BTYPE);\n\t\t\n\t\tif(BTYPE==0) {\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \n\t\t\tif(noBuf) buf=_check(buf, off+len);\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\n\t\t}\n\t\tif(noBuf) buf=_check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\n\t\tif(BTYPE==2) {\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\n\t\t\tvar tl = 1;\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\n\t\t\tmakeCodes(U.itree, tl);\n\t\t\tcodes2map(U.itree, tl, U.imap);\n\t\t\t\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\n\t\t\t\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\n\t\t\tvar mx0 = _copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\n\t\t\tvar mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\n\t\t\t\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\t\t\tmakeCodes(U.ltree, mx0);\n\t\t\tcodes2map(U.ltree, mx0, lmap);\n\t\t\t\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\t\t\tmakeCodes(U.dtree, mx1);\n\t\t\tcodes2map(U.dtree, mx1, dmap);\n\t\t}\n\t\t//var ooff=off, opos=pos;\n\t\twhile(true) {\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\n\t\t\telse if(lit==256) {  break;  }\n\t\t\telse {\n\t\t\t\tvar end = off+lit-254;\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\n\t\t\t\t//dst[end-off]++;\n\t\t\t\t\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\n\t\t\t\tvar dlit = dcode>>>4;\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\n\t\t\t\t\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\n\t\t\t\tif(noBuf) buf=_check(buf, off+(1<<17));\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \n\t\t\t\toff=end;\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\n\t\t\t}\n\t\t}\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\n\t}\n\t//console.log(dst);\n\t//console.log(tlen, dlen, off-tlen+tcnt);\n\treturn buf.length==off ? buf : buf.slice(0,off);\n}\nfunction _check(buf, len) {\n\tvar bl=buf.length;  if(len<=bl) return buf;\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\treturn nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n\tvar bitsE = _bitsE, get17 = _get17;\n\tvar i = 0;\n\twhile(i<len) {\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\n\t\tvar lit = code>>>4; \n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\n\t\telse {\n\t\t\tvar ll = 0, n = 0;\n\t\t\tif(lit==16) {\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\n\t\t\t}\n\t\t\telse if(lit==17) {\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\n\t\t\t}\n\t\t\telse if(lit==18) {\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\n\t\t\t}\n\t\t\tvar ni = i+n;\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\n\t\t}\n\t}\n\treturn pos;\n}\nfunction _copyOut(src, off, len, tree) {\n\tvar mx=0, i=0, tl=tree.length>>>1;\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\n\treturn mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {  // code, length\n\tvar max_code = tree.length;\n\tvar code, bits, n, i, len;\n\t\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\n\t\n\tvar next_code = U.next_code;\t// smallest code for each length\n\t\n\tcode = 0;\n\tbl_count[0] = 0;\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tcode = (code + bl_count[bits-1]) << 1;\n\t\tnext_code[bits] = code;\n\t}\n\t\n\tfor (n = 0; n < max_code; n+=2) {\n\t\tlen = tree[n+1];\n\t\tif (len != 0) {\n\t\t\ttree[n] = next_code[len];\n\t\t\tnext_code[len]++;\n\t\t}\n\t}\n}\nfunction codes2map(tree, MAX_BITS, map) {\n\tvar max_code = tree.length;\n\tvar r15 = U.rev15;\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\n\t\tvar lit = i>>1;\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\n\t\twhile(i0!=i1) {\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\n\t\t\tmap[p0]=val;  i0++;\n\t\t}\n\t}\n}\nfunction revCodes(tree, MAX_BITS) {\n\tvar r15 = U.rev15, imb = 15-MAX_BITS;\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\n}\n\nfunction _bitsE(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\nfunction _bitsF(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\nfunction _get17(dt, pos) {\t// return at least 17 meaningful bytes\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\n}\nconst U = function(){\n\tvar u16=Uint16Array, u32=Uint32Array;\n\treturn {\n\t\tnext_code : new u16(16),\n\t\tbl_count  : new u16(16),\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n\t\tldef : new u16(32),\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n\t\tddef : new u32(32),\n\t\tflmap: new u16(  512),  fltree: [],\n\t\tfdmap: new u16(   32),  fdtree: [],\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\n\t\tdmap : new u16(32768),  dtree : [],\n\t\timap : new u16(  512),  itree : [],\n\t\t//rev9 : new u16(  512)\n\t\trev15: new u16(1<<15),\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n\t\tlits : new u32(15000),\n\t\tstrt : new u16(1<<16),\n\t\tprev : new u16(1<<15)\n\t};  \n} ();\n\n(function(){\t\n\tvar len = 1<<15;\n\tfor(var i=0; i<len; i++) {\n\t\tvar x = i;\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n\t}\n\t\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n\t\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n\t\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n\t/*\n\tvar i = 0;\n\tfor(; i<=143; i++) U.fltree.push(0,8);\n\tfor(; i<=255; i++) U.fltree.push(0,9);\n\tfor(; i<=279; i++) U.fltree.push(0,7);\n\tfor(; i<=287; i++) U.fltree.push(0,8);\n\t*/\n\tmakeCodes(U.fltree, 9);\n\tcodes2map(U.fltree, 9, U.flmap);\n\trevCodes (U.fltree, 9);\n\t\n\tpushV(U.fdtree,32,5);\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\n\tmakeCodes(U.fdtree, 5);\n\tcodes2map(U.fdtree, 5, U.fdmap);\n\trevCodes (U.fdtree, 5);\n\t\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n\t/*\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\n\t*/\n})();\n\nconst crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }    \n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n};\n\nfunction inflateRaw(file, buf) {  return inflate(file, buf);  }\n\n/* global module */\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false,\n};\n\nlet nextId = 0;\n\n// Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\nlet numWorkers = 0;\nlet canUseWorkers = true;   // gets set to false if we can't start a worker\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {id, error, data} = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n}\n\n// Because Firefox uses non-standard onerror to signal an error.\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n    worker.onmessage = (e) => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\nconst workerHelper = (function() {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {Worker} = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n      addEventListener(worker, fn) {\n        worker.on('message', (data) => {\n          fn({target: worker, data});\n        });\n      },\n      async terminate(worker) {\n        await worker.terminate();\n      },\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so ¯\\_(ツ)_/¯\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n        try {\n          const req = await fetch(url, {mode: 'cors'});\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {type: 'application/javascript'}));\n          const worker = await startWorker(url);\n          config.workerURL = url;  // this is a hack. What's a better way to structure this code?\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      async terminate(worker) {\n        worker.terminate();\n      },\n    };\n  }\n}());\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers;  // see comment at numWorkers declaration\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n  return availableWorkers.pop();\n}\n\n// @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type\n     ? new Blob([dst], {type})\n     : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker();\n    // canUseWorkers might have been set out-of-band (need refactor)\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n        const {id, src, uncompressedSize, type, resolve, reject} = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {id, resolve, reject});\n        const transferables = [];\n        // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize,\n          },\n        }, transferables);\n      }\n      return;\n    }\n  }\n\n  // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n  while (waitingForWorkerQueue.length) {\n    const {src, uncompressedSize, type, resolve} = waitingForWorkerQueue.shift();\n    let data = src;\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL;\n  // there's no reason to set the workerURL if you're not going to use workers\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n}\n\n// It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({src, uncompressedSize, type, resolve, reject, id: nextId++});\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  const minute = time >> 5 & 0x3f; // 0-59\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n  }\n  // returns a promise that returns a Blob for this entry\n  async blob(type = 'application/octet-stream') {\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  }\n  // returns a promise that returns an ArrayBuffer for this entry\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  }\n  // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  }\n  // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n}\n\n// The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  },\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100 +\n         uint8View[offset + 2] * 0x10000 +\n         uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) +\n         getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n/* eslint-enable no-irregular-whitespace */\n\nconst utf8Decoder = new TextDecoder();\nfunction decodeBuffer(uint8View, isUTF8) {  /* eslint-disable-line no-unused-vars */ /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 0 - End of central directory signature\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);\n    // 4 - Number of this disk\n    const diskNumber = getUint16LE(eocdr, 4);\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = getUint16LE(eocdr, 10);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = getUint32LE(eocdr, 12);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = getUint32LE(eocdr, 16);\n    // 20 - Comment length\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    }\n\n    // 22 - Comment\n    // the encoding is always cp437.\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20);\n\n  // 0 - zip64 end of central dir locator signature\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = getUint64LE(eocdl, 8);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = getUint64LE(zip64Eocdr, 32);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40);\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);\n    // 0 - Central directory file header signature\n    const signature = getUint32LE(buffer, 0);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42),\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes);\n\n    // 46+n - Extra field\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd),\n      });\n      i = dataEnd;\n    }\n\n    // 46+n+m - File comment\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize            === 0xffffffff ||\n        rawEntry.compressedSize              === 0xffffffff ||\n        rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n      if (!zip64ExtraField) {\n        return new Error('expected zip64 extended information extra field');\n      }\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = rawEntry.extraFields.find(e =>\n        e.id === 0x7075 &&\n        e.data.length >= 6 && // too short to be meaningful\n        e.data[0] === 1 &&    // Version       1 byte      version of this extra field, currently 1\n        getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n                                                                   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n                                                                   // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n        // UnicodeName Variable UTF-8 version of the entry File Name\n        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    }\n\n    // validate file size\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n    rawEntries.push(rawEntry);\n  }\n  const zip = {\n    comment,\n    commentBytes,\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e)),\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n  // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n  const totalLength = await reader.getLength();\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = getUint32LE(buffer, 0);\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = getUint16LE(buffer, 26);\n  // 28 - Extra field length (m)\n  const extraFieldLength = getUint16LE(buffer, 28);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n  return {\n    decompress,\n    fileDataStart,\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);\n    // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  }\n  // see comment in readEntryDateAsBlob\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {type});\n  }\n  // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || (source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n}\n\n// If the names are not utf8 you should use unzipitRaw\nasync function unzip(source) {\n  const {zip, entries} = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v])),\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };\n"]},"metadata":{},"sourceType":"module"}