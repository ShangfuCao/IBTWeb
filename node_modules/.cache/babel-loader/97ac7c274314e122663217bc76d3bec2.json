{"ast":null,"code":"import { ConeGeometry, LineDashedMaterial, MeshBasicMaterial, Vector3 } from 'three';\nimport { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';\nimport { IfcComponent } from '../../../base-types';\nimport { IfcDimensionLine } from './dimension-line';\nexport class IfcDimensions extends IfcComponent {\n  constructor(context) {\n    super(context);\n    this.dimensions = [];\n    this.labelClassName = 'ifcjs-dimension-label';\n    this.previewClassName = 'ifcjs-dimension-preview'; // State\n\n    this.enabled = false;\n    this.preview = false;\n    this.dragging = false;\n    this.snapDistance = 0.25; // Measures\n\n    this.arrowHeight = 0.2;\n    this.arrowRadius = 0.05;\n    this.baseScale = new Vector3(1, 1, 1); // Materials\n\n    this.lineMaterial = new LineDashedMaterial({\n      color: 0x000000,\n      linewidth: 2,\n      depthTest: false,\n      dashSize: 0.2,\n      gapSize: 0.2\n    });\n    this.endpointsMaterial = new MeshBasicMaterial({\n      color: 0x000000,\n      depthTest: false\n    }); // Temp variables\n\n    this.startPoint = new Vector3();\n    this.endPoint = new Vector3();\n    this.context = context;\n    this.endpoint = this.getDefaultEndpointGeometry();\n    const htmlPreview = document.createElement('div');\n    htmlPreview.className = this.previewClassName;\n    this.previewElement = new CSS2DObject(htmlPreview);\n    this.previewElement.visible = false;\n  }\n\n  update(_delta) {\n    if (this.enabled && this.preview) {\n      const intersects = this.context.castRayIfc();\n      this.previewElement.visible = !!intersects;\n      if (!intersects) return;\n      this.previewElement.visible = true;\n      const closest = this.getClosestVertex(intersects);\n      this.previewElement.visible = !!closest;\n      if (!closest) return;\n      this.previewElement.position.set(closest.x, closest.y, closest.z);\n\n      if (this.dragging) {\n        this.drawInProcess();\n      }\n    }\n  }\n\n  get active() {\n    return this.enabled;\n  }\n\n  get previewActive() {\n    return this.preview;\n  }\n\n  get previewObject() {\n    return this.previewElement;\n  }\n\n  set previewActive(state) {\n    this.preview = state;\n    const scene = this.context.getScene();\n\n    if (this.preview) {\n      scene.add(this.previewElement);\n    } else {\n      scene.remove(this.previewElement);\n    }\n  }\n\n  set active(state) {\n    this.enabled = state;\n    this.dimensions.forEach(dim => {\n      dim.visibility = state;\n    });\n  }\n\n  set dimensionsColor(color) {\n    this.endpointsMaterial.color = color;\n    this.lineMaterial.color = color;\n  }\n\n  set dimensionsWidth(width) {\n    this.lineMaterial.linewidth = width;\n  }\n\n  set endpointGeometry(geometry) {\n    this.dimensions.forEach(dim => {\n      dim.endpointGeometry = geometry;\n    });\n  }\n\n  set endpointScaleFactor(factor) {\n    IfcDimensionLine.scaleFactor = factor;\n  }\n\n  set endpointScale(scale) {\n    this.baseScale = scale;\n    this.dimensions.forEach(dim => {\n      dim.endpointScale = scale;\n    });\n  }\n\n  create() {\n    if (!this.enabled) return;\n\n    if (!this.dragging) {\n      this.drawStart();\n      return;\n    }\n\n    this.drawEnd();\n  }\n\n  delete() {\n    if (!this.enabled || this.dimensions.length === 0) return;\n    const boundingBoxes = this.getBoundingBoxes();\n    const intersects = this.context.castRay(boundingBoxes);\n    if (intersects.length === 0) return;\n    const selected = this.dimensions.find(dim => dim.boundingBox === intersects[0].object);\n    if (!selected) return;\n    const index = this.dimensions.indexOf(selected);\n    this.dimensions.splice(index, 1);\n    selected.removeFromScene();\n  }\n\n  deleteAll() {\n    this.dimensions.forEach(dim => {\n      dim.removeFromScene();\n    });\n    this.dimensions = [];\n  }\n\n  cancelDrawing() {\n    var _a;\n\n    if (!this.currentDimension) return;\n    this.dragging = false;\n    (_a = this.currentDimension) === null || _a === void 0 ? void 0 : _a.removeFromScene();\n    this.currentDimension = undefined;\n  }\n\n  drawStart() {\n    this.dragging = true;\n    const intersects = this.context.castRayIfc();\n    if (!intersects) return;\n    const found = this.getClosestVertex(intersects);\n    if (!found) return;\n    this.startPoint = found;\n  }\n\n  drawInProcess() {\n    const intersects = this.context.castRayIfc();\n    if (!intersects) return;\n    const found = this.getClosestVertex(intersects);\n    if (!found) return;\n    this.endPoint = found;\n    if (!this.currentDimension) this.currentDimension = this.drawDimension();\n    this.currentDimension.endPoint = this.endPoint;\n  }\n\n  drawEnd() {\n    if (!this.currentDimension) return;\n    this.currentDimension.createBoundingBox();\n    this.dimensions.push(this.currentDimension);\n    this.currentDimension = undefined;\n    this.dragging = false;\n  }\n\n  drawDimension() {\n    return new IfcDimensionLine(this.context, this.startPoint, this.endPoint, this.lineMaterial, this.endpointsMaterial, this.endpoint, this.labelClassName, this.baseScale);\n  }\n\n  getBoundingBoxes() {\n    return this.dimensions.map(dim => dim.boundingBox).filter(box => box !== undefined);\n  }\n\n  getDefaultEndpointGeometry() {\n    const coneGeometry = new ConeGeometry(this.arrowRadius, this.arrowHeight);\n    coneGeometry.translate(0, -this.arrowHeight / 2, 0);\n    coneGeometry.rotateX(-Math.PI / 2);\n    return coneGeometry;\n  }\n\n  getClosestVertex(intersects) {\n    let closestVertex = new Vector3();\n    let vertexFound = false;\n    let closestDistance = Number.MAX_SAFE_INTEGER;\n    const vertices = this.getVertices(intersects);\n    vertices === null || vertices === void 0 ? void 0 : vertices.forEach(vertex => {\n      if (!vertex) return;\n      const distance = intersects.point.distanceTo(vertex);\n      if (distance > closestDistance || distance > this.snapDistance) return;\n      vertexFound = true;\n      closestVertex = vertex;\n      closestDistance = intersects.point.distanceTo(vertex);\n    });\n    return vertexFound ? closestVertex : intersects.point;\n  }\n\n  getVertices(intersects) {\n    const mesh = intersects.object;\n    if (!intersects.face || !mesh) return null;\n    const geom = mesh.geometry;\n    return [this.getVertex(intersects.face.a, geom), this.getVertex(intersects.face.b, geom), this.getVertex(intersects.face.c, geom)];\n  }\n\n  getVertex(index, geom) {\n    if (index === undefined) return null;\n    const vertices = geom.attributes.position;\n    return new Vector3(vertices.getX(index), vertices.getY(index), vertices.getZ(index));\n  }\n\n}","map":{"version":3,"sources":["../../../../src/components/display/dimensions/dimensions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ConeGeometry, LineDashedMaterial, MeshBasicMaterial, Vector3 } from 'three';\r\nimport { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';\r\nimport { IfcComponent } from '../../../base-types';\r\nimport { IfcDimensionLine } from './dimension-line';\r\nexport class IfcDimensions extends IfcComponent {\r\n    constructor(context) {\r\n        super(context);\r\n        this.dimensions = [];\r\n        this.labelClassName = 'ifcjs-dimension-label';\r\n        this.previewClassName = 'ifcjs-dimension-preview';\r\n        // State\r\n        this.enabled = false;\r\n        this.preview = false;\r\n        this.dragging = false;\r\n        this.snapDistance = 0.25;\r\n        // Measures\r\n        this.arrowHeight = 0.2;\r\n        this.arrowRadius = 0.05;\r\n        this.baseScale = new Vector3(1, 1, 1);\r\n        // Materials\r\n        this.lineMaterial = new LineDashedMaterial({\r\n            color: 0x000000,\r\n            linewidth: 2,\r\n            depthTest: false,\r\n            dashSize: 0.2,\r\n            gapSize: 0.2\r\n        });\r\n        this.endpointsMaterial = new MeshBasicMaterial({ color: 0x000000, depthTest: false });\r\n        // Temp variables\r\n        this.startPoint = new Vector3();\r\n        this.endPoint = new Vector3();\r\n        this.context = context;\r\n        this.endpoint = this.getDefaultEndpointGeometry();\r\n        const htmlPreview = document.createElement('div');\r\n        htmlPreview.className = this.previewClassName;\r\n        this.previewElement = new CSS2DObject(htmlPreview);\r\n        this.previewElement.visible = false;\r\n    }\r\n    update(_delta) {\r\n        if (this.enabled && this.preview) {\r\n            const intersects = this.context.castRayIfc();\r\n            this.previewElement.visible = !!intersects;\r\n            if (!intersects)\r\n                return;\r\n            this.previewElement.visible = true;\r\n            const closest = this.getClosestVertex(intersects);\r\n            this.previewElement.visible = !!closest;\r\n            if (!closest)\r\n                return;\r\n            this.previewElement.position.set(closest.x, closest.y, closest.z);\r\n            if (this.dragging) {\r\n                this.drawInProcess();\r\n            }\r\n        }\r\n    }\r\n    get active() {\r\n        return this.enabled;\r\n    }\r\n    get previewActive() {\r\n        return this.preview;\r\n    }\r\n    get previewObject() {\r\n        return this.previewElement;\r\n    }\r\n    set previewActive(state) {\r\n        this.preview = state;\r\n        const scene = this.context.getScene();\r\n        if (this.preview) {\r\n            scene.add(this.previewElement);\r\n        }\r\n        else {\r\n            scene.remove(this.previewElement);\r\n        }\r\n    }\r\n    set active(state) {\r\n        this.enabled = state;\r\n        this.dimensions.forEach((dim) => {\r\n            dim.visibility = state;\r\n        });\r\n    }\r\n    set dimensionsColor(color) {\r\n        this.endpointsMaterial.color = color;\r\n        this.lineMaterial.color = color;\r\n    }\r\n    set dimensionsWidth(width) {\r\n        this.lineMaterial.linewidth = width;\r\n    }\r\n    set endpointGeometry(geometry) {\r\n        this.dimensions.forEach((dim) => {\r\n            dim.endpointGeometry = geometry;\r\n        });\r\n    }\r\n    set endpointScaleFactor(factor) {\r\n        IfcDimensionLine.scaleFactor = factor;\r\n    }\r\n    set endpointScale(scale) {\r\n        this.baseScale = scale;\r\n        this.dimensions.forEach((dim) => {\r\n            dim.endpointScale = scale;\r\n        });\r\n    }\r\n    create() {\r\n        if (!this.enabled)\r\n            return;\r\n        if (!this.dragging) {\r\n            this.drawStart();\r\n            return;\r\n        }\r\n        this.drawEnd();\r\n    }\r\n    delete() {\r\n        if (!this.enabled || this.dimensions.length === 0)\r\n            return;\r\n        const boundingBoxes = this.getBoundingBoxes();\r\n        const intersects = this.context.castRay(boundingBoxes);\r\n        if (intersects.length === 0)\r\n            return;\r\n        const selected = this.dimensions.find((dim) => dim.boundingBox === intersects[0].object);\r\n        if (!selected)\r\n            return;\r\n        const index = this.dimensions.indexOf(selected);\r\n        this.dimensions.splice(index, 1);\r\n        selected.removeFromScene();\r\n    }\r\n    deleteAll() {\r\n        this.dimensions.forEach((dim) => {\r\n            dim.removeFromScene();\r\n        });\r\n        this.dimensions = [];\r\n    }\r\n    cancelDrawing() {\r\n        var _a;\r\n        if (!this.currentDimension)\r\n            return;\r\n        this.dragging = false;\r\n        (_a = this.currentDimension) === null || _a === void 0 ? void 0 : _a.removeFromScene();\r\n        this.currentDimension = undefined;\r\n    }\r\n    drawStart() {\r\n        this.dragging = true;\r\n        const intersects = this.context.castRayIfc();\r\n        if (!intersects)\r\n            return;\r\n        const found = this.getClosestVertex(intersects);\r\n        if (!found)\r\n            return;\r\n        this.startPoint = found;\r\n    }\r\n    drawInProcess() {\r\n        const intersects = this.context.castRayIfc();\r\n        if (!intersects)\r\n            return;\r\n        const found = this.getClosestVertex(intersects);\r\n        if (!found)\r\n            return;\r\n        this.endPoint = found;\r\n        if (!this.currentDimension)\r\n            this.currentDimension = this.drawDimension();\r\n        this.currentDimension.endPoint = this.endPoint;\r\n    }\r\n    drawEnd() {\r\n        if (!this.currentDimension)\r\n            return;\r\n        this.currentDimension.createBoundingBox();\r\n        this.dimensions.push(this.currentDimension);\r\n        this.currentDimension = undefined;\r\n        this.dragging = false;\r\n    }\r\n    drawDimension() {\r\n        return new IfcDimensionLine(this.context, this.startPoint, this.endPoint, this.lineMaterial, this.endpointsMaterial, this.endpoint, this.labelClassName, this.baseScale);\r\n    }\r\n    getBoundingBoxes() {\r\n        return this.dimensions\r\n            .map((dim) => dim.boundingBox)\r\n            .filter((box) => box !== undefined);\r\n    }\r\n    getDefaultEndpointGeometry() {\r\n        const coneGeometry = new ConeGeometry(this.arrowRadius, this.arrowHeight);\r\n        coneGeometry.translate(0, -this.arrowHeight / 2, 0);\r\n        coneGeometry.rotateX(-Math.PI / 2);\r\n        return coneGeometry;\r\n    }\r\n    getClosestVertex(intersects) {\r\n        let closestVertex = new Vector3();\r\n        let vertexFound = false;\r\n        let closestDistance = Number.MAX_SAFE_INTEGER;\r\n        const vertices = this.getVertices(intersects);\r\n        vertices === null || vertices === void 0 ? void 0 : vertices.forEach((vertex) => {\r\n            if (!vertex)\r\n                return;\r\n            const distance = intersects.point.distanceTo(vertex);\r\n            if (distance > closestDistance || distance > this.snapDistance)\r\n                return;\r\n            vertexFound = true;\r\n            closestVertex = vertex;\r\n            closestDistance = intersects.point.distanceTo(vertex);\r\n        });\r\n        return vertexFound ? closestVertex : intersects.point;\r\n    }\r\n    getVertices(intersects) {\r\n        const mesh = intersects.object;\r\n        if (!intersects.face || !mesh)\r\n            return null;\r\n        const geom = mesh.geometry;\r\n        return [\r\n            this.getVertex(intersects.face.a, geom),\r\n            this.getVertex(intersects.face.b, geom),\r\n            this.getVertex(intersects.face.c, geom)\r\n        ];\r\n    }\r\n    getVertex(index, geom) {\r\n        if (index === undefined)\r\n            return null;\r\n        const vertices = geom.attributes.position;\r\n        return new Vector3(vertices.getX(index), vertices.getY(index), vertices.getZ(index));\r\n    }\r\n}\r\n//# sourceMappingURL=dimensions.js.map"]},"metadata":{},"sourceType":"module"}