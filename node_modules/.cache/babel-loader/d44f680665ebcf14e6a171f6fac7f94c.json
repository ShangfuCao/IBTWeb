{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu\\u2019s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/* unzipit@1.3.3, license MIT */\n\n/* global SharedArrayBuffer, process */\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n    reader.addEventListener('loadend', function () {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nfunction readBlobAsUint8Array(_x) {\n  return _readBlobAsUint8Array.apply(this, arguments);\n}\n\nfunction _readBlobAsUint8Array() {\n  _readBlobAsUint8Array = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(blob) {\n    var arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            _context16.next = 2;\n            return readBlobAsArrayBuffer(blob);\n\n          case 2:\n            arrayBuffer = _context16.sent;\n            return _context16.abrupt(\"return\", new Uint8Array(arrayBuffer));\n\n          case 4:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _readBlobAsUint8Array.apply(this, arguments);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nvar isNode = typeof process !== 'undefined' && process.versions && typeof process.versions.node !== 'undefined' && typeof process.versions.electron === 'undefined';\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nvar ArrayBufferReader = /*#__PURE__*/function () {\n  function ArrayBufferReader(arrayBufferOrView) {\n    _classCallCheck(this, ArrayBufferReader);\n\n    this.typedArray = arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView) ? new Uint8Array(arrayBufferOrView) : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n\n  _createClass(ArrayBufferReader, [{\n    key: \"getLength\",\n    value: function () {\n      var _getLength = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.typedArray.byteLength);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getLength() {\n        return _getLength.apply(this, arguments);\n      }\n\n      return getLength;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(offset, length) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read(_x2, _x3) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }]);\n\n  return ArrayBufferReader;\n}();\n\nvar BlobReader = /*#__PURE__*/function () {\n  function BlobReader(blob) {\n    _classCallCheck(this, BlobReader);\n\n    this.blob = blob;\n  }\n\n  _createClass(BlobReader, [{\n    key: \"getLength\",\n    value: function () {\n      var _getLength2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.blob.size);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getLength() {\n        return _getLength2.apply(this, arguments);\n      }\n\n      return getLength;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(offset, length) {\n        var blob, arrayBuffer;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                blob = this.blob.slice(offset, offset + length);\n                _context4.next = 3;\n                return readBlobAsArrayBuffer(blob);\n\n              case 3:\n                arrayBuffer = _context4.sent;\n                return _context4.abrupt(\"return\", new Uint8Array(arrayBuffer));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function read(_x4, _x5) {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"sliceAsBlob\",\n    value: function () {\n      var _sliceAsBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(offset, length) {\n        var type,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                type = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : '';\n                return _context5.abrupt(\"return\", this.blob.slice(offset, offset + length, type));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sliceAsBlob(_x6, _x7) {\n        return _sliceAsBlob.apply(this, arguments);\n      }\n\n      return sliceAsBlob;\n    }()\n  }]);\n\n  return BlobReader;\n}();\n\nvar HTTPRangeReader = /*#__PURE__*/function () {\n  function HTTPRangeReader(url) {\n    _classCallCheck(this, HTTPRangeReader);\n\n    this.url = url;\n  }\n\n  _createClass(HTTPRangeReader, [{\n    key: \"getLength\",\n    value: function () {\n      var _getLength3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var req;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this.length === undefined)) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                _context6.next = 3;\n                return fetch(this.url, {\n                  method: 'HEAD'\n                });\n\n              case 3:\n                req = _context6.sent;\n\n                if (req.ok) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw new Error(\"failed http request \".concat(this.url, \", status: \").concat(req.status, \": \").concat(req.statusText));\n\n              case 6:\n                this.length = parseInt(req.headers.get('content-length'));\n\n                if (!Number.isNaN(this.length)) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                throw Error('could not get length');\n\n              case 9:\n                return _context6.abrupt(\"return\", this.length);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getLength() {\n        return _getLength3.apply(this, arguments);\n      }\n\n      return getLength;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(offset, size) {\n        var req, buffer;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(size === 0)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", new Uint8Array(0));\n\n              case 2:\n                _context7.next = 4;\n                return fetch(this.url, {\n                  headers: {\n                    Range: \"bytes=\".concat(offset, \"-\").concat(offset + size - 1)\n                  }\n                });\n\n              case 4:\n                req = _context7.sent;\n\n                if (req.ok) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                throw new Error(\"failed http request \".concat(this.url, \", status: \").concat(req.status, \" offset: \").concat(offset, \" size: \").concat(size, \": \").concat(req.statusText));\n\n              case 7:\n                _context7.next = 9;\n                return req.arrayBuffer();\n\n              case 9:\n                buffer = _context7.sent;\n                return _context7.abrupt(\"return\", new Uint8Array(buffer));\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function read(_x8, _x9) {\n        return _read3.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }]);\n\n  return HTTPRangeReader;\n}();\n\nfunction inflate(data, buf) {\n  var u8 = Uint8Array;\n  if (data[0] == 3 && data[1] == 0) return buf ? buf : new u8(0);\n  var bitsF = _bitsF,\n      bitsE = _bitsE,\n      decodeTiny = _decodeTiny,\n      get17 = _get17;\n  var noBuf = buf == null;\n  if (noBuf) buf = new u8(data.length >>> 2 << 3);\n  var BFINAL = 0,\n      BTYPE = 0,\n      HLIT = 0,\n      HDIST = 0,\n      HCLEN = 0,\n      ML = 0,\n      MD = 0;\n  var off = 0,\n      pos = 0;\n  var lmap, dmap;\n\n  while (BFINAL == 0) {\n    BFINAL = bitsF(data, pos, 1);\n    BTYPE = bitsF(data, pos + 1, 2);\n    pos += 3; //console.log(BFINAL, BTYPE);\n\n    if (BTYPE == 0) {\n      if ((pos & 7) != 0) pos += 8 - (pos & 7);\n      var p8 = (pos >>> 3) + 4,\n          len = data[p8 - 4] | data[p8 - 3] << 8; //console.log(len);//bitsF(data, pos, 16), \n\n      if (noBuf) buf = _check(buf, off + len);\n      buf.set(new u8(data.buffer, data.byteOffset + p8, len), off); //for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n      //for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\n      pos = p8 + len << 3;\n      off += len;\n      continue;\n    }\n\n    if (noBuf) buf = _check(buf, off + (1 << 17)); // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\n    if (BTYPE == 1) {\n      lmap = U.flmap;\n      dmap = U.fdmap;\n      ML = (1 << 9) - 1;\n      MD = (1 << 5) - 1;\n    }\n\n    if (BTYPE == 2) {\n      HLIT = bitsE(data, pos, 5) + 257;\n      HDIST = bitsE(data, pos + 5, 5) + 1;\n      HCLEN = bitsE(data, pos + 10, 4) + 4;\n      pos += 14;\n\n      for (var i = 0; i < 38; i += 2) {\n        U.itree[i] = 0;\n        U.itree[i + 1] = 0;\n      }\n\n      var tl = 1;\n\n      for (var i = 0; i < HCLEN; i++) {\n        var l = bitsE(data, pos + i * 3, 3);\n        U.itree[(U.ordr[i] << 1) + 1] = l;\n        if (l > tl) tl = l;\n      }\n\n      pos += 3 * HCLEN; //console.log(itree);\n\n      makeCodes(U.itree, tl);\n      codes2map(U.itree, tl, U.imap);\n      lmap = U.lmap;\n      dmap = U.dmap;\n      pos = decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);\n\n      var mx0 = _copyOut(U.ttree, 0, HLIT, U.ltree);\n\n      ML = (1 << mx0) - 1;\n\n      var mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);\n\n      MD = (1 << mx1) - 1; //var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\n      makeCodes(U.ltree, mx0);\n      codes2map(U.ltree, mx0, lmap); //var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\n      makeCodes(U.dtree, mx1);\n      codes2map(U.dtree, mx1, dmap);\n    } //var ooff=off, opos=pos;\n\n\n    while (true) {\n      var code = lmap[get17(data, pos) & ML];\n      pos += code & 15;\n      var lit = code >>> 4; //U.lhst[lit]++;  \n\n      if (lit >>> 8 == 0) {\n        buf[off++] = lit;\n      } else if (lit == 256) {\n        break;\n      } else {\n        var end = off + lit - 254;\n\n        if (lit > 264) {\n          var ebs = U.ldef[lit - 257];\n          end = off + (ebs >>> 3) + bitsE(data, pos, ebs & 7);\n          pos += ebs & 7;\n        } //dst[end-off]++;\n\n\n        var dcode = dmap[get17(data, pos) & MD];\n        pos += dcode & 15;\n        var dlit = dcode >>> 4;\n        var dbs = U.ddef[dlit],\n            dst = (dbs >>> 4) + bitsF(data, pos, dbs & 15);\n        pos += dbs & 15; //var o0 = off-dst, stp = Math.min(end-off, dst);\n        //if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n        //if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n        //if(dst==1) buf.fill(buf[off-1], off, end);  else\n\n        if (noBuf) buf = _check(buf, off + (1 << 17));\n\n        while (off < end) {\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n          buf[off] = buf[off++ - dst];\n        }\n\n        off = end; //while(off!=end) {  buf[off]=buf[off++-dst];  }\n      }\n    } //console.log(off-ooff, (pos-opos)>>>3);\n\n  } //console.log(dst);\n  //console.log(tlen, dlen, off-tlen+tcnt);\n\n\n  return buf.length == off ? buf : buf.slice(0, off);\n}\n\nfunction _check(buf, len) {\n  var bl = buf.length;\n  if (len <= bl) return buf;\n  var nbuf = new Uint8Array(Math.max(bl << 1, len));\n  nbuf.set(buf, 0); //for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\n  return nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n  var bitsE = _bitsE,\n      get17 = _get17;\n  var i = 0;\n\n  while (i < len) {\n    var code = lmap[get17(data, pos) & LL];\n    pos += code & 15;\n    var lit = code >>> 4;\n\n    if (lit <= 15) {\n      tree[i] = lit;\n      i++;\n    } else {\n      var ll = 0,\n          n = 0;\n\n      if (lit == 16) {\n        n = 3 + bitsE(data, pos, 2);\n        pos += 2;\n        ll = tree[i - 1];\n      } else if (lit == 17) {\n        n = 3 + bitsE(data, pos, 3);\n        pos += 3;\n      } else if (lit == 18) {\n        n = 11 + bitsE(data, pos, 7);\n        pos += 7;\n      }\n\n      var ni = i + n;\n\n      while (i < ni) {\n        tree[i] = ll;\n        i++;\n      }\n    }\n  }\n\n  return pos;\n}\n\nfunction _copyOut(src, off, len, tree) {\n  var mx = 0,\n      i = 0,\n      tl = tree.length >>> 1;\n\n  while (i < len) {\n    var v = src[i + off];\n    tree[i << 1] = 0;\n    tree[(i << 1) + 1] = v;\n    if (v > mx) mx = v;\n    i++;\n  }\n\n  while (i < tl) {\n    tree[i << 1] = 0;\n    tree[(i << 1) + 1] = 0;\n    i++;\n  }\n\n  return mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {\n  // code, length\n  var max_code = tree.length;\n  var code, bits, n, i, len;\n  var bl_count = U.bl_count;\n\n  for (var i = 0; i <= MAX_BITS; i++) {\n    bl_count[i] = 0;\n  }\n\n  for (i = 1; i < max_code; i += 2) {\n    bl_count[tree[i]]++;\n  }\n\n  var next_code = U.next_code; // smallest code for each length\n\n  code = 0;\n  bl_count[0] = 0;\n\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    code = code + bl_count[bits - 1] << 1;\n    next_code[bits] = code;\n  }\n\n  for (n = 0; n < max_code; n += 2) {\n    len = tree[n + 1];\n\n    if (len != 0) {\n      tree[n] = next_code[len];\n      next_code[len]++;\n    }\n  }\n}\n\nfunction codes2map(tree, MAX_BITS, map) {\n  var max_code = tree.length;\n  var r15 = U.rev15;\n\n  for (var i = 0; i < max_code; i += 2) {\n    if (tree[i + 1] != 0) {\n      var lit = i >> 1;\n      var cl = tree[i + 1],\n          val = lit << 4 | cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\n      var rest = MAX_BITS - cl,\n          i0 = tree[i] << rest,\n          i1 = i0 + (1 << rest); //tree[i]=r15[i0]>>>(15-MAX_BITS);\n\n      while (i0 != i1) {\n        var p0 = r15[i0] >>> 15 - MAX_BITS;\n        map[p0] = val;\n        i0++;\n      }\n    }\n  }\n}\n\nfunction revCodes(tree, MAX_BITS) {\n  var r15 = U.rev15,\n      imb = 15 - MAX_BITS;\n\n  for (var i = 0; i < tree.length; i += 2) {\n    var i0 = tree[i] << MAX_BITS - tree[i + 1];\n    tree[i] = r15[i0] >>> imb;\n  }\n}\n\nfunction _bitsE(dt, pos, length) {\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;\n}\n\nfunction _bitsF(dt, pos, length) {\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;\n}\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\n\n\nfunction _get17(dt, pos) {\n  // return at least 17 meaningful bytes\n  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7);\n}\n\nvar U = function () {\n  var u16 = Uint16Array,\n      u32 = Uint32Array;\n  return {\n    next_code: new u16(16),\n    bl_count: new u16(16),\n    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n    ldef: new u16(32),\n    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n    ddef: new u32(32),\n    flmap: new u16(512),\n    fltree: [],\n    fdmap: new u16(32),\n    fdtree: [],\n    lmap: new u16(32768),\n    ltree: [],\n    ttree: [],\n    dmap: new u16(32768),\n    dtree: [],\n    imap: new u16(512),\n    itree: [],\n    //rev9 : new u16(  512)\n    rev15: new u16(1 << 15),\n    lhst: new u32(286),\n    dhst: new u32(30),\n    ihst: new u32(19),\n    lits: new u32(15000),\n    strt: new u16(1 << 16),\n    prev: new u16(1 << 15)\n  };\n}();\n\n(function () {\n  var len = 1 << 15;\n\n  for (var i = 0; i < len; i++) {\n    var x = i;\n    x = (x & 0xaaaaaaaa) >>> 1 | (x & 0x55555555) << 1;\n    x = (x & 0xcccccccc) >>> 2 | (x & 0x33333333) << 2;\n    x = (x & 0xf0f0f0f0) >>> 4 | (x & 0x0f0f0f0f) << 4;\n    x = (x & 0xff00ff00) >>> 8 | (x & 0x00ff00ff) << 8;\n    U.rev15[i] = (x >>> 16 | x << 16) >>> 17;\n  }\n\n  function pushV(tgt, n, sv) {\n    while (n-- != 0) {\n      tgt.push(0, sv);\n    }\n  }\n\n  for (var i = 0; i < 32; i++) {\n    U.ldef[i] = U.of0[i] << 3 | U.exb[i];\n    U.ddef[i] = U.df0[i] << 4 | U.dxb[i];\n  }\n\n  pushV(U.fltree, 144, 8);\n  pushV(U.fltree, 255 - 143, 9);\n  pushV(U.fltree, 279 - 255, 7);\n  pushV(U.fltree, 287 - 279, 8);\n  /*\n  var i = 0;\n  for(; i<=143; i++) U.fltree.push(0,8);\n  for(; i<=255; i++) U.fltree.push(0,9);\n  for(; i<=279; i++) U.fltree.push(0,7);\n  for(; i<=287; i++) U.fltree.push(0,8);\n  */\n\n  makeCodes(U.fltree, 9);\n  codes2map(U.fltree, 9, U.flmap);\n  revCodes(U.fltree, 9);\n  pushV(U.fdtree, 32, 5); //for(i=0;i<32; i++) U.fdtree.push(0,5);\n\n  makeCodes(U.fdtree, 5);\n  codes2map(U.fdtree, 5, U.fdmap);\n  revCodes(U.fdtree, 5);\n  pushV(U.itree, 19, 0);\n  pushV(U.ltree, 286, 0);\n  pushV(U.dtree, 30, 0);\n  pushV(U.ttree, 320, 0);\n  /*\n  for(var i=0; i< 19; i++) U.itree.push(0,0);\n  for(var i=0; i<286; i++) U.ltree.push(0,0);\n  for(var i=0; i< 30; i++) U.dtree.push(0,0);\n  for(var i=0; i<320; i++) U.ttree.push(0,0);\n  */\n})();\n\nvar _crc = {\n  table: function () {\n    var tab = new Uint32Array(256);\n\n    for (var n = 0; n < 256; n++) {\n      var c = n;\n\n      for (var k = 0; k < 8; k++) {\n        if (c & 1) c = 0xedb88320 ^ c >>> 1;else c = c >>> 1;\n      }\n\n      tab[n] = c;\n    }\n\n    return tab;\n  }(),\n  update: function update(c, buf, off, len) {\n    for (var i = 0; i < len; i++) {\n      c = _crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;\n    }\n\n    return c;\n  },\n  crc: function crc(b, o, l) {\n    return _crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\n  }\n};\n\nfunction inflateRaw(file, buf) {\n  return inflate(file, buf);\n}\n/* global module */\n\n\nvar config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false\n};\nvar nextId = 0; // Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\n\nvar numWorkers = 0;\nvar canUseWorkers = true; // gets set to false if we can't start a worker\n\nvar workers = [];\nvar availableWorkers = [];\nvar waitingForWorkerQueue = [];\nvar currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  var _e$data = e.data,\n      id = _e$data.id,\n      error = _e$data.error,\n      data = _e$data.data;\n  var request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n} // Because Firefox uses non-standard onerror to signal an error.\n\n\nfunction startWorker(url) {\n  return new Promise(function (resolve, reject) {\n    var worker = new Worker(url);\n\n    worker.onmessage = function (e) {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(\"unexpected message: \".concat(e.data)));\n      }\n    };\n\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\nvar workerHelper = function () {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    var _dynamicRequire = dynamicRequire(module, 'worker_threads'),\n        _Worker = _dynamicRequire.Worker;\n\n    return {\n      createWorker: function createWorker(url) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n          return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  return _context8.abrupt(\"return\", new _Worker(url));\n\n                case 1:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }))();\n      },\n      addEventListener: function addEventListener(worker, fn) {\n        worker.on('message', function (data) {\n          fn({\n            target: worker,\n            data: data\n          });\n        });\n      },\n      terminate: function terminate(worker) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n          return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  _context9.next = 2;\n                  return worker.terminate();\n\n                case 2:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9);\n        }))();\n      }\n    };\n  } else {\n    return {\n      createWorker: function createWorker(url) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n          var worker, text, req, _worker, _worker2;\n\n          return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  _context10.prev = 0;\n                  _context10.next = 3;\n                  return startWorker(url);\n\n                case 3:\n                  worker = _context10.sent;\n                  return _context10.abrupt(\"return\", worker);\n\n                case 7:\n                  _context10.prev = 7;\n                  _context10.t0 = _context10[\"catch\"](0);\n                  console.warn('could not load worker:', url);\n\n                case 10:\n                  _context10.prev = 10;\n                  _context10.next = 13;\n                  return fetch(url, {\n                    mode: 'cors'\n                  });\n\n                case 13:\n                  req = _context10.sent;\n\n                  if (req.ok) {\n                    _context10.next = 16;\n                    break;\n                  }\n\n                  throw new Error(\"could not load: \".concat(url));\n\n                case 16:\n                  _context10.next = 18;\n                  return req.text();\n\n                case 18:\n                  text = _context10.sent;\n                  url = URL.createObjectURL(new Blob([text], {\n                    type: 'application/javascript'\n                  }));\n                  _context10.next = 22;\n                  return startWorker(url);\n\n                case 22:\n                  _worker = _context10.sent;\n                  config.workerURL = url; // this is a hack. What's a better way to structure this code?\n\n                  return _context10.abrupt(\"return\", _worker);\n\n                case 27:\n                  _context10.prev = 27;\n                  _context10.t1 = _context10[\"catch\"](10);\n                  console.warn('could not load worker via fetch:', url);\n\n                case 30:\n                  if (!(text !== undefined)) {\n                    _context10.next = 43;\n                    break;\n                  }\n\n                  _context10.prev = 31;\n                  url = \"data:application/javascript;base64,\".concat(btoa(text));\n                  _context10.next = 35;\n                  return startWorker(url);\n\n                case 35:\n                  _worker2 = _context10.sent;\n                  config.workerURL = url;\n                  return _context10.abrupt(\"return\", _worker2);\n\n                case 40:\n                  _context10.prev = 40;\n                  _context10.t2 = _context10[\"catch\"](31);\n                  console.warn('could not load worker via dataURI');\n\n                case 43:\n                  console.warn('workers will not be used');\n                  throw new Error('can not start workers');\n\n                case 45:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10, null, [[0, 7], [10, 27], [31, 40]]);\n        }))();\n      },\n      addEventListener: function addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      terminate: function terminate(worker) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n          return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  worker.terminate();\n\n                case 1:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11);\n        }))();\n      }\n    };\n  }\n}();\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nfunction getAvailableWorker() {\n  return _getAvailableWorker.apply(this, arguments);\n} // @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\n\n\nfunction _getAvailableWorker() {\n  _getAvailableWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n    var worker;\n    return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            if (!(availableWorkers.length === 0 && numWorkers < config.numWorkers)) {\n              _context17.next = 14;\n              break;\n            }\n\n            ++numWorkers; // see comment at numWorkers declaration\n\n            _context17.prev = 2;\n            _context17.next = 5;\n            return workerHelper.createWorker(config.workerURL);\n\n          case 5:\n            worker = _context17.sent;\n            workers.push(worker);\n            availableWorkers.push(worker);\n            workerHelper.addEventListener(worker, handleResult);\n            _context17.next = 14;\n            break;\n\n          case 11:\n            _context17.prev = 11;\n            _context17.t0 = _context17[\"catch\"](2);\n            // set this global out-of-band (needs refactor)\n            canUseWorkers = false;\n\n          case 14:\n            return _context17.abrupt(\"return\", availableWorkers.pop());\n\n          case 15:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17, null, [[2, 11]]);\n  }));\n  return _getAvailableWorker.apply(this, arguments);\n}\n\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  var dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type ? new Blob([dst], {\n    type: type\n  }) : dst.buffer);\n}\n\nfunction processWaitingForWorkerQueue() {\n  return _processWaitingForWorkerQueue.apply(this, arguments);\n}\n\nfunction _processWaitingForWorkerQueue() {\n  _processWaitingForWorkerQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n    var worker, _waitingForWorkerQueu, id, src, uncompressedSize, type, resolve, reject, transferables, _waitingForWorkerQueu2, _src, _uncompressedSize, _type, _resolve, data;\n\n    return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            if (!(waitingForWorkerQueue.length === 0)) {\n              _context18.next = 2;\n              break;\n            }\n\n            return _context18.abrupt(\"return\");\n\n          case 2:\n            if (!(config.useWorkers && canUseWorkers)) {\n              _context18.next = 16;\n              break;\n            }\n\n            _context18.next = 5;\n            return getAvailableWorker();\n\n          case 5:\n            worker = _context18.sent;\n\n            if (!canUseWorkers) {\n              _context18.next = 16;\n              break;\n            }\n\n            if (!worker) {\n              _context18.next = 15;\n              break;\n            }\n\n            if (!(waitingForWorkerQueue.length === 0)) {\n              _context18.next = 11;\n              break;\n            }\n\n            // the queue might be empty while we awaited for a worker.\n            makeWorkerAvailable(worker);\n            return _context18.abrupt(\"return\");\n\n          case 11:\n            _waitingForWorkerQueu = waitingForWorkerQueue.shift(), id = _waitingForWorkerQueu.id, src = _waitingForWorkerQueu.src, uncompressedSize = _waitingForWorkerQueu.uncompressedSize, type = _waitingForWorkerQueu.type, resolve = _waitingForWorkerQueu.resolve, reject = _waitingForWorkerQueu.reject;\n            currentlyProcessingIdToRequestMap.set(id, {\n              id: id,\n              resolve: resolve,\n              reject: reject\n            });\n            transferables = []; // NOTE: Originally I thought you could transfer an ArrayBuffer.\n            // The code on this side is often using views into the entire file\n            // which means if we transferred we'd lose the entire file. That sucks\n            // because it means there's an expensive copy to send the uncompressed\n            // data to the worker.\n            //\n            // Also originally I thought we could send a Blob but we'd need to refactor\n            // the code in unzipit/readEntryData as currently it reads the uncompressed\n            // bytes.\n            //\n            //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n            //  transferables.push(src);\n            //}\n\n            worker.postMessage({\n              type: 'inflate',\n              data: {\n                id: id,\n                type: type,\n                src: src,\n                uncompressedSize: uncompressedSize\n              }\n            }, transferables);\n\n          case 15:\n            return _context18.abrupt(\"return\");\n\n          case 16:\n            if (!waitingForWorkerQueue.length) {\n              _context18.next = 26;\n              break;\n            }\n\n            _waitingForWorkerQueu2 = waitingForWorkerQueue.shift(), _src = _waitingForWorkerQueu2.src, _uncompressedSize = _waitingForWorkerQueu2.uncompressedSize, _type = _waitingForWorkerQueu2.type, _resolve = _waitingForWorkerQueu2.resolve;\n            data = _src;\n\n            if (!isBlob(_src)) {\n              _context18.next = 23;\n              break;\n            }\n\n            _context18.next = 22;\n            return readBlobAsUint8Array(_src);\n\n          case 22:\n            data = _context18.sent;\n\n          case 23:\n            inflateRawLocal(data, _uncompressedSize, _type, _resolve);\n            _context18.next = 16;\n            break;\n\n          case 26:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18);\n  }));\n  return _processWaitingForWorkerQueue.apply(this, arguments);\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL; // there's no reason to set the workerURL if you're not going to use workers\n\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n} // It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\n\n\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise(function (resolve, reject) {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({\n      src: src,\n      uncompressedSize: uncompressedSize,\n      type: type,\n      resolve: resolve,\n      reject: reject,\n      id: nextId++\n    });\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nfunction cleanup() {\n  return _cleanup.apply(this, arguments);\n}\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\n\nfunction _cleanup() {\n  _cleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n    var _iterator, _step, worker;\n\n    return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            _iterator = _createForOfIteratorHelper(workers);\n            _context19.prev = 1;\n\n            _iterator.s();\n\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context19.next = 9;\n              break;\n            }\n\n            worker = _step.value;\n            _context19.next = 7;\n            return workerHelper.terminate(worker);\n\n          case 7:\n            _context19.next = 3;\n            break;\n\n          case 9:\n            _context19.next = 14;\n            break;\n\n          case 11:\n            _context19.prev = 11;\n            _context19.t0 = _context19[\"catch\"](1);\n\n            _iterator.e(_context19.t0);\n\n          case 14:\n            _context19.prev = 14;\n\n            _iterator.f();\n\n            return _context19.finish(14);\n\n          case 17:\n            clearArray(workers);\n            clearArray(availableWorkers);\n            clearArray(waitingForWorkerQueue);\n            currentlyProcessingIdToRequestMap.clear();\n            numWorkers = 0;\n            canUseWorkers = true;\n\n          case 23:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19, null, [[1, 11, 14, 17]]);\n  }));\n  return _cleanup.apply(this, arguments);\n}\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n\n  var minute = time >> 5 & 0x3f; // 0-59\n\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nvar ZipEntry = /*#__PURE__*/function () {\n  function ZipEntry(reader, rawEntry) {\n    _classCallCheck(this, ZipEntry);\n\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n  } // returns a promise that returns a Blob for this entry\n\n\n  _createClass(ZipEntry, [{\n    key: \"blob\",\n    value: function () {\n      var _blob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var type,\n            _args12 = arguments;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                type = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : 'application/octet-stream';\n                _context12.next = 3;\n                return readEntryDataAsBlob(this._reader, this._rawEntry, type);\n\n              case 3:\n                return _context12.abrupt(\"return\", _context12.sent);\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function blob() {\n        return _blob.apply(this, arguments);\n      }\n\n      return blob;\n    }() // returns a promise that returns an ArrayBuffer for this entry\n\n  }, {\n    key: \"arrayBuffer\",\n    value: function () {\n      var _arrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n\n              case 2:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function arrayBuffer() {\n        return _arrayBuffer.apply(this, arguments);\n      }\n\n      return arrayBuffer;\n    }() // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n\n  }, {\n    key: \"text\",\n    value: function () {\n      var _text = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.arrayBuffer();\n\n              case 2:\n                buffer = _context14.sent;\n                return _context14.abrupt(\"return\", decodeBuffer(new Uint8Array(buffer)));\n\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function text() {\n        return _text.apply(this, arguments);\n      }\n\n      return text;\n    }() // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n\n  }, {\n    key: \"json\",\n    value: function () {\n      var _json = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n        var text;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.text();\n\n              case 2:\n                text = _context15.sent;\n                return _context15.abrupt(\"return\", JSON.parse(text));\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function json() {\n        return _json.apply(this, arguments);\n      }\n\n      return json;\n    }()\n  }]);\n\n  return ZipEntry;\n}();\n\nvar EOCDR_WITHOUT_COMMENT_SIZE = 22;\nvar MAX_COMMENT_SIZE = 0xffff; // 2-byte size\n\nvar EOCDR_SIGNATURE = 0x06054b50;\nvar ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nfunction readAs(_x10, _x11, _x12) {\n  return _readAs.apply(this, arguments);\n} // The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\n\n\nfunction _readAs() {\n  _readAs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(reader, offset, length) {\n    return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            _context20.next = 2;\n            return reader.read(offset, length);\n\n          case 2:\n            return _context20.abrupt(\"return\", _context20.sent);\n\n          case 3:\n          case \"end\":\n            return _context20.stop();\n        }\n      }\n    }, _callee20);\n  }));\n  return _readAs.apply(this, arguments);\n}\n\nfunction readAsBlobOrTypedArray(_x13, _x14, _x15, _x16) {\n  return _readAsBlobOrTypedArray.apply(this, arguments);\n}\n\nfunction _readAsBlobOrTypedArray() {\n  _readAsBlobOrTypedArray = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(reader, offset, length, type) {\n    return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            if (!reader.sliceAsBlob) {\n              _context21.next = 4;\n              break;\n            }\n\n            _context21.next = 3;\n            return reader.sliceAsBlob(offset, length, type);\n\n          case 3:\n            return _context21.abrupt(\"return\", _context21.sent);\n\n          case 4:\n            _context21.next = 6;\n            return reader.read(offset, length);\n\n          case 6:\n            return _context21.abrupt(\"return\", _context21.sent);\n\n          case 7:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, _callee21);\n  }));\n  return _readAsBlobOrTypedArray.apply(this, arguments);\n}\n\nvar crc$1 = {\n  unsigned: function unsigned() {\n    return 0;\n  }\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset] + uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset] + uint8View[offset + 1] * 0x100 + uint8View[offset + 2] * 0x10000 + uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) + getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n\n/* eslint-enable no-irregular-whitespace */\n\n\nvar utf8Decoder = new TextDecoder();\n\nfunction decodeBuffer(uint8View, isUTF8) {\n  /* eslint-disable-line no-unused-vars */\n\n  /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nfunction findEndOfCentralDirector(_x17, _x18) {\n  return _findEndOfCentralDirector.apply(this, arguments);\n}\n\nfunction _findEndOfCentralDirector() {\n  _findEndOfCentralDirector = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(reader, totalLength) {\n    var size, readStart, data, i, eocdr, diskNumber, entryCount, centralDirectorySize, centralDirectoryOffset, commentLength, expectedCommentLength, commentBytes, comment;\n    return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n      while (1) {\n        switch (_context22.prev = _context22.next) {\n          case 0:\n            size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n            readStart = totalLength - size;\n            _context22.next = 4;\n            return readAs(reader, readStart, size);\n\n          case 4:\n            data = _context22.sent;\n            i = size - EOCDR_WITHOUT_COMMENT_SIZE;\n\n          case 6:\n            if (!(i >= 0)) {\n              _context22.next = 34;\n              break;\n            }\n\n            if (!(getUint32LE(data, i) !== EOCDR_SIGNATURE)) {\n              _context22.next = 9;\n              break;\n            }\n\n            return _context22.abrupt(\"continue\", 31);\n\n          case 9:\n            // 0 - End of central directory signature\n            eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i); // 4 - Number of this disk\n\n            diskNumber = getUint16LE(eocdr, 4);\n\n            if (!(diskNumber !== 0)) {\n              _context22.next = 13;\n              break;\n            }\n\n            throw new Error(\"multi-volume zip files are not supported. This is volume: \".concat(diskNumber));\n\n          case 13:\n            // 6 - Disk where central directory starts\n            // 8 - Number of central directory records on this disk\n            // 10 - Total number of central directory records\n            entryCount = getUint16LE(eocdr, 10); // 12 - Size of central directory (bytes)\n\n            centralDirectorySize = getUint32LE(eocdr, 12); // 16 - Offset of start of central directory, relative to start of archive\n\n            centralDirectoryOffset = getUint32LE(eocdr, 16); // 20 - Comment length\n\n            commentLength = getUint16LE(eocdr, 20);\n            expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n\n            if (!(commentLength !== expectedCommentLength)) {\n              _context22.next = 20;\n              break;\n            }\n\n            throw new Error(\"invalid comment length. expected: \".concat(expectedCommentLength, \", actual: \").concat(commentLength));\n\n          case 20:\n            // 22 - Comment\n            // the encoding is always cp437.\n            commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n            comment = decodeBuffer(commentBytes);\n\n            if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n              _context22.next = 28;\n              break;\n            }\n\n            _context22.next = 25;\n            return readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n\n          case 25:\n            return _context22.abrupt(\"return\", _context22.sent);\n\n          case 28:\n            _context22.next = 30;\n            return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n\n          case 30:\n            return _context22.abrupt(\"return\", _context22.sent);\n\n          case 31:\n            --i;\n            _context22.next = 6;\n            break;\n\n          case 34:\n            throw new Error('could not find end of central directory. maybe not zip file');\n\n          case 35:\n          case \"end\":\n            return _context22.stop();\n        }\n      }\n    }, _callee22);\n  }));\n  return _findEndOfCentralDirector.apply(this, arguments);\n}\n\nvar END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nfunction readZip64CentralDirectory(_x19, _x20, _x21, _x22) {\n  return _readZip64CentralDirectory.apply(this, arguments);\n}\n\nfunction _readZip64CentralDirectory() {\n  _readZip64CentralDirectory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(reader, offset, comment, commentBytes) {\n    var zip64EocdlOffset, eocdl, zip64EocdrOffset, zip64Eocdr, entryCount, centralDirectorySize, centralDirectoryOffset;\n    return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n      while (1) {\n        switch (_context23.prev = _context23.next) {\n          case 0:\n            // ZIP64 Zip64 end of central directory locator\n            zip64EocdlOffset = offset - 20;\n            _context23.next = 3;\n            return readAs(reader, zip64EocdlOffset, 20);\n\n          case 3:\n            eocdl = _context23.sent;\n\n            if (!(getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE)) {\n              _context23.next = 6;\n              break;\n            }\n\n            throw new Error('invalid zip64 end of central directory locator signature');\n\n          case 6:\n            // 4 - number of the disk with the start of the zip64 end of central directory\n            // 8 - relative offset of the zip64 end of central directory record\n            zip64EocdrOffset = getUint64LE(eocdl, 8); // 16 - total number of disks\n            // ZIP64 end of central directory record\n\n            _context23.next = 9;\n            return readAs(reader, zip64EocdrOffset, 56);\n\n          case 9:\n            zip64Eocdr = _context23.sent;\n\n            if (!(getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE)) {\n              _context23.next = 12;\n              break;\n            }\n\n            throw new Error('invalid zip64 end of central directory record signature');\n\n          case 12:\n            // 4 - size of zip64 end of central directory record                8 bytes\n            // 12 - version made by                                             2 bytes\n            // 14 - version needed to extract                                   2 bytes\n            // 16 - number of this disk                                         4 bytes\n            // 20 - number of the disk with the start of the central directory  4 bytes\n            // 24 - total number of entries in the central directory on this disk         8 bytes\n            // 32 - total number of entries in the central directory            8 bytes\n            entryCount = getUint64LE(zip64Eocdr, 32); // 40 - size of the central directory                               8 bytes\n\n            centralDirectorySize = getUint64LE(zip64Eocdr, 40); // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n\n            centralDirectoryOffset = getUint64LE(zip64Eocdr, 48); // 56 - zip64 extensible data sector                                (variable size)\n\n            return _context23.abrupt(\"return\", readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes));\n\n          case 16:\n          case \"end\":\n            return _context23.stop();\n        }\n      }\n    }, _callee23);\n  }));\n  return _readZip64CentralDirectory.apply(this, arguments);\n}\n\nvar CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nfunction readEntries(_x23, _x24, _x25, _x26, _x27, _x28) {\n  return _readEntries.apply(this, arguments);\n}\n\nfunction _readEntries() {\n  _readEntries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n    var readEntryCursor, allEntriesBuffer, rawEntries, e, buffer, signature, rawEntry, data, fileCommentStart, extraFieldBuffer, i, headerId, dataSize, dataStart, dataEnd, zip64ExtraField, zip64EiefBuffer, index, nameField, expectedCompressedSize, zip;\n    return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n      while (1) {\n        switch (_context24.prev = _context24.next) {\n          case 0:\n            readEntryCursor = 0;\n            _context24.next = 3;\n            return readAs(reader, centralDirectoryOffset, centralDirectorySize);\n\n          case 3:\n            allEntriesBuffer = _context24.sent;\n            rawEntries = [];\n            e = 0;\n\n          case 6:\n            if (!(e < rawEntryCount)) {\n              _context24.next = 68;\n              break;\n            }\n\n            buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46); // 0 - Central directory file header signature\n\n            signature = getUint32LE(buffer, 0);\n\n            if (!(signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE)) {\n              _context24.next = 11;\n              break;\n            }\n\n            throw new Error(\"invalid central directory file header signature: 0x\".concat(signature.toString(16)));\n\n          case 11:\n            rawEntry = {\n              // 4 - Version made by\n              versionMadeBy: getUint16LE(buffer, 4),\n              // 6 - Version needed to extract (minimum)\n              versionNeededToExtract: getUint16LE(buffer, 6),\n              // 8 - General purpose bit flag\n              generalPurposeBitFlag: getUint16LE(buffer, 8),\n              // 10 - Compression method\n              compressionMethod: getUint16LE(buffer, 10),\n              // 12 - File last modification time\n              lastModFileTime: getUint16LE(buffer, 12),\n              // 14 - File last modification date\n              lastModFileDate: getUint16LE(buffer, 14),\n              // 16 - CRC-32\n              crc32: getUint32LE(buffer, 16),\n              // 20 - Compressed size\n              compressedSize: getUint32LE(buffer, 20),\n              // 24 - Uncompressed size\n              uncompressedSize: getUint32LE(buffer, 24),\n              // 28 - File name length (n)\n              fileNameLength: getUint16LE(buffer, 28),\n              // 30 - Extra field length (m)\n              extraFieldLength: getUint16LE(buffer, 30),\n              // 32 - File comment length (k)\n              fileCommentLength: getUint16LE(buffer, 32),\n              // 34 - Disk number where file starts\n              // 36 - Internal file attributes\n              internalFileAttributes: getUint16LE(buffer, 36),\n              // 38 - External file attributes\n              externalFileAttributes: getUint32LE(buffer, 38),\n              // 42 - Relative offset of local file header\n              relativeOffsetOfLocalHeader: getUint32LE(buffer, 42)\n            };\n\n            if (!(rawEntry.generalPurposeBitFlag & 0x40)) {\n              _context24.next = 14;\n              break;\n            }\n\n            throw new Error('strong encryption is not supported');\n\n          case 14:\n            readEntryCursor += 46;\n            data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n            rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n            rawEntry.name = decodeBuffer(rawEntry.nameBytes); // 46+n - Extra field\n\n            fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n            extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n            rawEntry.extraFields = [];\n            i = 0;\n\n          case 22:\n            if (!(i < extraFieldBuffer.length - 3)) {\n              _context24.next = 33;\n              break;\n            }\n\n            headerId = getUint16LE(extraFieldBuffer, i + 0);\n            dataSize = getUint16LE(extraFieldBuffer, i + 2);\n            dataStart = i + 4;\n            dataEnd = dataStart + dataSize;\n\n            if (!(dataEnd > extraFieldBuffer.length)) {\n              _context24.next = 29;\n              break;\n            }\n\n            throw new Error('extra field length exceeds extra field buffer size');\n\n          case 29:\n            rawEntry.extraFields.push({\n              id: headerId,\n              data: extraFieldBuffer.slice(dataStart, dataEnd)\n            });\n            i = dataEnd;\n            _context24.next = 22;\n            break;\n\n          case 33:\n            // 46+n+m - File comment\n            rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n            rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n            readEntryCursor += data.length;\n\n            if (!(rawEntry.uncompressedSize === 0xffffffff || rawEntry.compressedSize === 0xffffffff || rawEntry.relativeOffsetOfLocalHeader === 0xffffffff)) {\n              _context24.next = 57;\n              break;\n            }\n\n            // ZIP64 format\n            // find the Zip64 Extended Information Extra Field\n            zip64ExtraField = rawEntry.extraFields.find(function (e) {\n              return e.id === 0x0001;\n            });\n\n            if (zip64ExtraField) {\n              _context24.next = 40;\n              break;\n            }\n\n            return _context24.abrupt(\"return\", new Error('expected zip64 extended information extra field'));\n\n          case 40:\n            zip64EiefBuffer = zip64ExtraField.data;\n            index = 0; // 0 - Original Size          8 bytes\n\n            if (!(rawEntry.uncompressedSize === 0xffffffff)) {\n              _context24.next = 47;\n              break;\n            }\n\n            if (!(index + 8 > zip64EiefBuffer.length)) {\n              _context24.next = 45;\n              break;\n            }\n\n            throw new Error('zip64 extended information extra field does not include uncompressed size');\n\n          case 45:\n            rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n            index += 8;\n\n          case 47:\n            if (!(rawEntry.compressedSize === 0xffffffff)) {\n              _context24.next = 52;\n              break;\n            }\n\n            if (!(index + 8 > zip64EiefBuffer.length)) {\n              _context24.next = 50;\n              break;\n            }\n\n            throw new Error('zip64 extended information extra field does not include compressed size');\n\n          case 50:\n            rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n            index += 8;\n\n          case 52:\n            if (!(rawEntry.relativeOffsetOfLocalHeader === 0xffffffff)) {\n              _context24.next = 57;\n              break;\n            }\n\n            if (!(index + 8 > zip64EiefBuffer.length)) {\n              _context24.next = 55;\n              break;\n            }\n\n            throw new Error('zip64 extended information extra field does not include relative header offset');\n\n          case 55:\n            rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n            index += 8;\n\n          case 57:\n            // check for Info-ZIP Unicode Path Extra Field (0x7075)\n            // see https://github.com/thejoshwolfe/yauzl/issues/33\n            nameField = rawEntry.extraFields.find(function (e) {\n              return e.id === 0x7075 && e.data.length >= 6 && // too short to be meaningful\n              e.data[0] === 1 && // Version       1 byte      version of this extra field, currently 1\n              getUint32LE(e.data, 1);\n            }, crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n            // > If the CRC check fails, this UTF-8 Path Extra Field should be\n            // > ignored and the File Name field in the header should be used instead.\n\n            if (nameField) {\n              // UnicodeName Variable UTF-8 version of the entry File Name\n              rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n            } // validate file size\n\n\n            if (!(rawEntry.compressionMethod === 0)) {\n              _context24.next = 64;\n              break;\n            }\n\n            expectedCompressedSize = rawEntry.uncompressedSize;\n\n            if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n              // traditional encryption prefixes the file data with a header\n              expectedCompressedSize += 12;\n            }\n\n            if (!(rawEntry.compressedSize !== expectedCompressedSize)) {\n              _context24.next = 64;\n              break;\n            }\n\n            throw new Error(\"compressed size mismatch for stored file: \".concat(rawEntry.compressedSize, \" != \").concat(expectedCompressedSize));\n\n          case 64:\n            rawEntries.push(rawEntry);\n\n          case 65:\n            ++e;\n            _context24.next = 6;\n            break;\n\n          case 68:\n            zip = {\n              comment: comment,\n              commentBytes: commentBytes\n            };\n            return _context24.abrupt(\"return\", {\n              zip: zip,\n              entries: rawEntries.map(function (e) {\n                return new ZipEntry(reader, e);\n              })\n            });\n\n          case 70:\n          case \"end\":\n            return _context24.stop();\n        }\n      }\n    }, _callee24);\n  }));\n  return _readEntries.apply(this, arguments);\n}\n\nfunction readEntryDataHeader(_x29, _x30) {\n  return _readEntryDataHeader.apply(this, arguments);\n}\n\nfunction _readEntryDataHeader() {\n  _readEntryDataHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(reader, rawEntry) {\n    var buffer, totalLength, signature, fileNameLength, extraFieldLength, localFileHeaderEnd, decompress, fileDataStart, fileDataEnd;\n    return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n      while (1) {\n        switch (_context25.prev = _context25.next) {\n          case 0:\n            if (!(rawEntry.generalPurposeBitFlag & 0x1)) {\n              _context25.next = 2;\n              break;\n            }\n\n            throw new Error('encrypted entries not supported');\n\n          case 2:\n            _context25.next = 4;\n            return readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n\n          case 4:\n            buffer = _context25.sent;\n            _context25.next = 7;\n            return reader.getLength();\n\n          case 7:\n            totalLength = _context25.sent;\n            // 0 - Local file header signature = 0x04034b50\n            signature = getUint32LE(buffer, 0);\n\n            if (!(signature !== 0x04034b50)) {\n              _context25.next = 11;\n              break;\n            }\n\n            throw new Error(\"invalid local file header signature: 0x\".concat(signature.toString(16)));\n\n          case 11:\n            // all this should be redundant\n            // 4 - Version needed to extract (minimum)\n            // 6 - General purpose bit flag\n            // 8 - Compression method\n            // 10 - File last modification time\n            // 12 - File last modification date\n            // 14 - CRC-32\n            // 18 - Compressed size\n            // 22 - Uncompressed size\n            // 26 - File name length (n)\n            fileNameLength = getUint16LE(buffer, 26); // 28 - Extra field length (m)\n\n            extraFieldLength = getUint16LE(buffer, 28); // 30 - File name\n            // 30+n - Extra field\n\n            localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n\n            if (!(rawEntry.compressionMethod === 0)) {\n              _context25.next = 18;\n              break;\n            }\n\n            // 0 - The file is stored (no compression)\n            decompress = false;\n            _context25.next = 23;\n            break;\n\n          case 18:\n            if (!(rawEntry.compressionMethod === 8)) {\n              _context25.next = 22;\n              break;\n            }\n\n            // 8 - The file is Deflated\n            decompress = true;\n            _context25.next = 23;\n            break;\n\n          case 22:\n            throw new Error(\"unsupported compression method: \".concat(rawEntry.compressionMethod));\n\n          case 23:\n            fileDataStart = localFileHeaderEnd;\n            fileDataEnd = fileDataStart + rawEntry.compressedSize;\n\n            if (!(rawEntry.compressedSize !== 0)) {\n              _context25.next = 28;\n              break;\n            }\n\n            if (!(fileDataEnd > totalLength)) {\n              _context25.next = 28;\n              break;\n            }\n\n            throw new Error(\"file data overflows file bounds: \".concat(fileDataStart, \" +  \").concat(rawEntry.compressedSize, \"  > \").concat(totalLength));\n\n          case 28:\n            return _context25.abrupt(\"return\", {\n              decompress: decompress,\n              fileDataStart: fileDataStart\n            });\n\n          case 29:\n          case \"end\":\n            return _context25.stop();\n        }\n      }\n    }, _callee25);\n  }));\n  return _readEntryDataHeader.apply(this, arguments);\n}\n\nfunction readEntryDataAsArrayBuffer(_x31, _x32) {\n  return _readEntryDataAsArrayBuffer.apply(this, arguments);\n}\n\nfunction _readEntryDataAsArrayBuffer() {\n  _readEntryDataAsArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(reader, rawEntry) {\n    var _yield$readEntryDataH, decompress, fileDataStart, dataView, typedArrayOrBlob, result;\n\n    return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n      while (1) {\n        switch (_context26.prev = _context26.next) {\n          case 0:\n            _context26.next = 2;\n            return readEntryDataHeader(reader, rawEntry);\n\n          case 2:\n            _yield$readEntryDataH = _context26.sent;\n            decompress = _yield$readEntryDataH.decompress;\n            fileDataStart = _yield$readEntryDataH.fileDataStart;\n\n            if (decompress) {\n              _context26.next = 10;\n              break;\n            }\n\n            _context26.next = 8;\n            return readAs(reader, fileDataStart, rawEntry.compressedSize);\n\n          case 8:\n            dataView = _context26.sent;\n            return _context26.abrupt(\"return\", isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer);\n\n          case 10:\n            _context26.next = 12;\n            return readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n\n          case 12:\n            typedArrayOrBlob = _context26.sent;\n            _context26.next = 15;\n            return inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n\n          case 15:\n            result = _context26.sent;\n            return _context26.abrupt(\"return\", result);\n\n          case 17:\n          case \"end\":\n            return _context26.stop();\n        }\n      }\n    }, _callee26);\n  }));\n  return _readEntryDataAsArrayBuffer.apply(this, arguments);\n}\n\nfunction readEntryDataAsBlob(_x33, _x34, _x35) {\n  return _readEntryDataAsBlob.apply(this, arguments);\n}\n\nfunction _readEntryDataAsBlob() {\n  _readEntryDataAsBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27(reader, rawEntry, type) {\n    var _yield$readEntryDataH2, decompress, fileDataStart, _typedArrayOrBlob, typedArrayOrBlob, result;\n\n    return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n      while (1) {\n        switch (_context27.prev = _context27.next) {\n          case 0:\n            _context27.next = 2;\n            return readEntryDataHeader(reader, rawEntry);\n\n          case 2:\n            _yield$readEntryDataH2 = _context27.sent;\n            decompress = _yield$readEntryDataH2.decompress;\n            fileDataStart = _yield$readEntryDataH2.fileDataStart;\n\n            if (decompress) {\n              _context27.next = 12;\n              break;\n            }\n\n            _context27.next = 8;\n            return readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n\n          case 8:\n            _typedArrayOrBlob = _context27.sent;\n\n            if (!isBlob(_typedArrayOrBlob)) {\n              _context27.next = 11;\n              break;\n            }\n\n            return _context27.abrupt(\"return\", _typedArrayOrBlob);\n\n          case 11:\n            return _context27.abrupt(\"return\", new Blob([isSharedArrayBuffer(_typedArrayOrBlob.buffer) ? new Uint8Array(_typedArrayOrBlob) : _typedArrayOrBlob], {\n              type: type\n            }));\n\n          case 12:\n            _context27.next = 14;\n            return readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n\n          case 14:\n            typedArrayOrBlob = _context27.sent;\n            _context27.next = 17;\n            return inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n\n          case 17:\n            result = _context27.sent;\n            return _context27.abrupt(\"return\", result);\n\n          case 19:\n          case \"end\":\n            return _context27.stop();\n        }\n      }\n    }, _callee27);\n  }));\n  return _readEntryDataAsBlob.apply(this, arguments);\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nfunction unzipRaw(_x36) {\n  return _unzipRaw.apply(this, arguments);\n} // If the names are not utf8 you should use unzipitRaw\n\n\nfunction _unzipRaw() {\n  _unzipRaw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee28(source) {\n    var reader, req, blob, totalLength;\n    return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n      while (1) {\n        switch (_context28.prev = _context28.next) {\n          case 0:\n            if (!(typeof Blob !== 'undefined' && source instanceof Blob)) {\n              _context28.next = 4;\n              break;\n            }\n\n            reader = new BlobReader(source);\n            _context28.next = 29;\n            break;\n\n          case 4:\n            if (!(source instanceof ArrayBuffer || source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n              _context28.next = 8;\n              break;\n            }\n\n            reader = new ArrayBufferReader(source);\n            _context28.next = 29;\n            break;\n\n          case 8:\n            if (!(isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer))) {\n              _context28.next = 12;\n              break;\n            }\n\n            reader = new ArrayBufferReader(source);\n            _context28.next = 29;\n            break;\n\n          case 12:\n            if (!(typeof source === 'string')) {\n              _context28.next = 24;\n              break;\n            }\n\n            _context28.next = 15;\n            return fetch(source);\n\n          case 15:\n            req = _context28.sent;\n\n            if (req.ok) {\n              _context28.next = 18;\n              break;\n            }\n\n            throw new Error(\"failed http request \".concat(source, \", status: \").concat(req.status, \": \").concat(req.statusText));\n\n          case 18:\n            _context28.next = 20;\n            return req.blob();\n\n          case 20:\n            blob = _context28.sent;\n            reader = new BlobReader(blob);\n            _context28.next = 29;\n            break;\n\n          case 24:\n            if (!(typeof source.getLength === 'function' && typeof source.read === 'function')) {\n              _context28.next = 28;\n              break;\n            }\n\n            reader = source;\n            _context28.next = 29;\n            break;\n\n          case 28:\n            throw new Error('unsupported source type');\n\n          case 29:\n            _context28.next = 31;\n            return reader.getLength();\n\n          case 31:\n            totalLength = _context28.sent;\n\n            if (!(totalLength > Number.MAX_SAFE_INTEGER)) {\n              _context28.next = 34;\n              break;\n            }\n\n            throw new Error(\"file too large. size: \".concat(totalLength, \". Only file sizes up 4503599627370496 bytes are supported\"));\n\n          case 34:\n            _context28.next = 36;\n            return findEndOfCentralDirector(reader, totalLength);\n\n          case 36:\n            return _context28.abrupt(\"return\", _context28.sent);\n\n          case 37:\n          case \"end\":\n            return _context28.stop();\n        }\n      }\n    }, _callee28);\n  }));\n  return _unzipRaw.apply(this, arguments);\n}\n\nfunction unzip(_x37) {\n  return _unzip.apply(this, arguments);\n}\n\nfunction _unzip() {\n  _unzip = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee29(source) {\n    var _yield$unzipRaw, zip, entries;\n\n    return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n      while (1) {\n        switch (_context29.prev = _context29.next) {\n          case 0:\n            _context29.next = 2;\n            return unzipRaw(source);\n\n          case 2:\n            _yield$unzipRaw = _context29.sent;\n            zip = _yield$unzipRaw.zip;\n            entries = _yield$unzipRaw.entries;\n            return _context29.abrupt(\"return\", {\n              zip: zip,\n              entries: Object.fromEntries(entries.map(function (v) {\n                return [v.name, v];\n              }))\n            });\n\n          case 6:\n          case \"end\":\n            return _context29.stop();\n        }\n      }\n    }, _callee29);\n  }));\n  return _unzip.apply(this, arguments);\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };","map":{"version":3,"sources":["/Users/shangfualexcao/Dropbox (Personal)/My Mac (Shangfu’s MacBook Pro)/Documents/GitHub/IBT-Web/frontend/node_modules/unzipit/dist/unzipit.module.js"],"names":["readBlobAsArrayBuffer","blob","arrayBuffer","Promise","resolve","reject","reader","FileReader","addEventListener","result","readAsArrayBuffer","readBlobAsUint8Array","Uint8Array","isBlob","v","Blob","isSharedArrayBuffer","b","SharedArrayBuffer","isNode","process","versions","node","electron","isTypedArraySameAsArrayBuffer","typedArray","byteOffset","byteLength","buffer","ArrayBufferReader","arrayBufferOrView","ArrayBuffer","offset","length","BlobReader","size","slice","type","HTTPRangeReader","url","undefined","fetch","method","req","ok","Error","status","statusText","parseInt","headers","get","Number","isNaN","Range","inflate","data","buf","u8","bitsF","_bitsF","bitsE","_bitsE","decodeTiny","_decodeTiny","get17","_get17","noBuf","BFINAL","BTYPE","HLIT","HDIST","HCLEN","ML","MD","off","pos","lmap","dmap","p8","len","_check","set","U","flmap","fdmap","i","itree","tl","l","ordr","makeCodes","codes2map","imap","ttree","mx0","_copyOut","ltree","mx1","dtree","code","lit","end","ebs","ldef","dcode","dlit","dbs","ddef","dst","bl","nbuf","Math","max","LL","tree","ll","n","ni","src","mx","MAX_BITS","max_code","bits","bl_count","next_code","map","r15","rev15","cl","val","rest","i0","i1","p0","revCodes","imb","dt","u16","Uint16Array","u32","Uint32Array","of0","exb","df0","dxb","fltree","fdtree","lhst","dhst","ihst","lits","strt","prev","x","pushV","tgt","sv","push","crc","table","tab","c","k","update","o","inflateRaw","file","config","numWorkers","workerURL","useWorkers","nextId","canUseWorkers","workers","availableWorkers","waitingForWorkerQueue","currentlyProcessingIdToRequestMap","Map","handleResult","e","makeWorkerAvailable","target","id","error","request","delete","startWorker","worker","Worker","onmessage","onerror","dynamicRequire","mod","require","workerHelper","module","createWorker","fn","on","terminate","console","warn","mode","text","URL","createObjectURL","btoa","processWaitingForWorkerQueue","getAvailableWorker","pop","inflateRawLocal","uncompressedSize","shift","transferables","postMessage","setOptions","options","inflateRawAsync","clearArray","arr","splice","cleanup","clear","dosDateTimeToDate","date","time","day","month","year","millisecond","second","minute","hour","Date","ZipEntry","rawEntry","_reader","_rawEntry","name","nameBytes","compressedSize","comment","commentBytes","compressionMethod","lastModDate","lastModFileDate","lastModFileTime","isDirectory","endsWith","encrypted","generalPurposeBitFlag","readEntryDataAsBlob","readEntryDataAsArrayBuffer","decodeBuffer","JSON","parse","EOCDR_WITHOUT_COMMENT_SIZE","MAX_COMMENT_SIZE","EOCDR_SIGNATURE","ZIP64_EOCDR_SIGNATURE","readAs","read","readAsBlobOrTypedArray","sliceAsBlob","crc$1","unsigned","getUint16LE","uint8View","getUint32LE","getUint64LE","utf8Decoder","TextDecoder","isUTF8","decode","findEndOfCentralDirector","totalLength","min","readStart","eocdr","diskNumber","entryCount","centralDirectorySize","centralDirectoryOffset","commentLength","expectedCommentLength","readZip64CentralDirectory","readEntries","END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE","zip64EocdlOffset","eocdl","zip64EocdrOffset","zip64Eocdr","CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE","rawEntryCount","readEntryCursor","allEntriesBuffer","rawEntries","subarray","signature","toString","versionMadeBy","versionNeededToExtract","crc32","fileNameLength","extraFieldLength","fileCommentLength","internalFileAttributes","externalFileAttributes","relativeOffsetOfLocalHeader","fileCommentStart","extraFieldBuffer","extraFields","headerId","dataSize","dataStart","dataEnd","zip64ExtraField","find","zip64EiefBuffer","index","nameField","fileName","expectedCompressedSize","zip","entries","readEntryDataHeader","getLength","localFileHeaderEnd","decompress","fileDataStart","fileDataEnd","dataView","typedArrayOrBlob","setOptions$1","unzipRaw","source","MAX_SAFE_INTEGER","unzip","Object","fromEntries","cleanup$1"],"mappings":"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","sourcesContent":["/* unzipit@1.3.3, license MIT */\n/* global SharedArrayBuffer, process */\n\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode =\n    (typeof process !== 'undefined') &&\n    process.versions &&\n    (typeof process.versions.node !== 'undefined') &&\n    (typeof process.versions.electron === 'undefined');\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = (arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView))\n       ? new Uint8Array(arrayBufferOrView)\n       : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n  async getLength() {\n    return this.blob.size;\n  }\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n  async sliceAsBlob(offset, length, type = '') {\n    return this.blob.slice(offset, offset + length, type);\n  }\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, { method: 'HEAD' });\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n      this.length = parseInt(req.headers.get('content-length'));\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n    return this.length;\n  }\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`,\n      },\n    });\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n}\n\nfunction inflate(data, buf) {\n\tvar u8=Uint8Array;\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\n\tvar bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;\n\t\n\tvar noBuf = (buf==null);\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\n\t\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\n\tvar off = 0, pos = 0;\n\tvar lmap, dmap;\n\t\n\twhile(BFINAL==0) {\t\t\n\t\tBFINAL = bitsF(data, pos  , 1);\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\n\t\t//console.log(BFINAL, BTYPE);\n\t\t\n\t\tif(BTYPE==0) {\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \n\t\t\tif(noBuf) buf=_check(buf, off+len);\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\n\t\t}\n\t\tif(noBuf) buf=_check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\n\t\tif(BTYPE==2) {\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\n\t\t\tvar tl = 1;\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\n\t\t\tmakeCodes(U.itree, tl);\n\t\t\tcodes2map(U.itree, tl, U.imap);\n\t\t\t\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\n\t\t\t\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\n\t\t\tvar mx0 = _copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\n\t\t\tvar mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\n\t\t\t\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\t\t\tmakeCodes(U.ltree, mx0);\n\t\t\tcodes2map(U.ltree, mx0, lmap);\n\t\t\t\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\t\t\tmakeCodes(U.dtree, mx1);\n\t\t\tcodes2map(U.dtree, mx1, dmap);\n\t\t}\n\t\t//var ooff=off, opos=pos;\n\t\twhile(true) {\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\n\t\t\telse if(lit==256) {  break;  }\n\t\t\telse {\n\t\t\t\tvar end = off+lit-254;\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\n\t\t\t\t//dst[end-off]++;\n\t\t\t\t\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\n\t\t\t\tvar dlit = dcode>>>4;\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\n\t\t\t\t\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\n\t\t\t\tif(noBuf) buf=_check(buf, off+(1<<17));\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \n\t\t\t\toff=end;\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\n\t\t\t}\n\t\t}\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\n\t}\n\t//console.log(dst);\n\t//console.log(tlen, dlen, off-tlen+tcnt);\n\treturn buf.length==off ? buf : buf.slice(0,off);\n}\nfunction _check(buf, len) {\n\tvar bl=buf.length;  if(len<=bl) return buf;\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\treturn nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n\tvar bitsE = _bitsE, get17 = _get17;\n\tvar i = 0;\n\twhile(i<len) {\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\n\t\tvar lit = code>>>4; \n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\n\t\telse {\n\t\t\tvar ll = 0, n = 0;\n\t\t\tif(lit==16) {\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\n\t\t\t}\n\t\t\telse if(lit==17) {\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\n\t\t\t}\n\t\t\telse if(lit==18) {\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\n\t\t\t}\n\t\t\tvar ni = i+n;\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\n\t\t}\n\t}\n\treturn pos;\n}\nfunction _copyOut(src, off, len, tree) {\n\tvar mx=0, i=0, tl=tree.length>>>1;\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\n\treturn mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {  // code, length\n\tvar max_code = tree.length;\n\tvar code, bits, n, i, len;\n\t\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\n\t\n\tvar next_code = U.next_code;\t// smallest code for each length\n\t\n\tcode = 0;\n\tbl_count[0] = 0;\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tcode = (code + bl_count[bits-1]) << 1;\n\t\tnext_code[bits] = code;\n\t}\n\t\n\tfor (n = 0; n < max_code; n+=2) {\n\t\tlen = tree[n+1];\n\t\tif (len != 0) {\n\t\t\ttree[n] = next_code[len];\n\t\t\tnext_code[len]++;\n\t\t}\n\t}\n}\nfunction codes2map(tree, MAX_BITS, map) {\n\tvar max_code = tree.length;\n\tvar r15 = U.rev15;\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\n\t\tvar lit = i>>1;\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\n\t\twhile(i0!=i1) {\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\n\t\t\tmap[p0]=val;  i0++;\n\t\t}\n\t}\n}\nfunction revCodes(tree, MAX_BITS) {\n\tvar r15 = U.rev15, imb = 15-MAX_BITS;\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\n}\n\nfunction _bitsE(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\nfunction _bitsF(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\nfunction _get17(dt, pos) {\t// return at least 17 meaningful bytes\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\n}\nconst U = function(){\n\tvar u16=Uint16Array, u32=Uint32Array;\n\treturn {\n\t\tnext_code : new u16(16),\n\t\tbl_count  : new u16(16),\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n\t\tldef : new u16(32),\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n\t\tddef : new u32(32),\n\t\tflmap: new u16(  512),  fltree: [],\n\t\tfdmap: new u16(   32),  fdtree: [],\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\n\t\tdmap : new u16(32768),  dtree : [],\n\t\timap : new u16(  512),  itree : [],\n\t\t//rev9 : new u16(  512)\n\t\trev15: new u16(1<<15),\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n\t\tlits : new u32(15000),\n\t\tstrt : new u16(1<<16),\n\t\tprev : new u16(1<<15)\n\t};  \n} ();\n\n(function(){\t\n\tvar len = 1<<15;\n\tfor(var i=0; i<len; i++) {\n\t\tvar x = i;\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n\t}\n\t\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n\t\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n\t\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n\t/*\n\tvar i = 0;\n\tfor(; i<=143; i++) U.fltree.push(0,8);\n\tfor(; i<=255; i++) U.fltree.push(0,9);\n\tfor(; i<=279; i++) U.fltree.push(0,7);\n\tfor(; i<=287; i++) U.fltree.push(0,8);\n\t*/\n\tmakeCodes(U.fltree, 9);\n\tcodes2map(U.fltree, 9, U.flmap);\n\trevCodes (U.fltree, 9);\n\t\n\tpushV(U.fdtree,32,5);\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\n\tmakeCodes(U.fdtree, 5);\n\tcodes2map(U.fdtree, 5, U.fdmap);\n\trevCodes (U.fdtree, 5);\n\t\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n\t/*\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\n\t*/\n})();\n\nconst crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }    \n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n};\n\nfunction inflateRaw(file, buf) {  return inflate(file, buf);  }\n\n/* global module */\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false,\n};\n\nlet nextId = 0;\n\n// Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\nlet numWorkers = 0;\nlet canUseWorkers = true;   // gets set to false if we can't start a worker\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {id, error, data} = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n}\n\n// Because Firefox uses non-standard onerror to signal an error.\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n    worker.onmessage = (e) => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require(request);\n}\n\nconst workerHelper = (function() {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {Worker} = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n      addEventListener(worker, fn) {\n        worker.on('message', (data) => {\n          fn({target: worker, data});\n        });\n      },\n      async terminate(worker) {\n        await worker.terminate();\n      },\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so ¯\\_(ツ)_/¯\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n        try {\n          const req = await fetch(url, {mode: 'cors'});\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {type: 'application/javascript'}));\n          const worker = await startWorker(url);\n          config.workerURL = url;  // this is a hack. What's a better way to structure this code?\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      async terminate(worker) {\n        worker.terminate();\n      },\n    };\n  }\n}());\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers;  // see comment at numWorkers declaration\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n  return availableWorkers.pop();\n}\n\n// @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type\n     ? new Blob([dst], {type})\n     : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker();\n    // canUseWorkers might have been set out-of-band (need refactor)\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n        const {id, src, uncompressedSize, type, resolve, reject} = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {id, resolve, reject});\n        const transferables = [];\n        // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize,\n          },\n        }, transferables);\n      }\n      return;\n    }\n  }\n\n  // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n  while (waitingForWorkerQueue.length) {\n    const {src, uncompressedSize, type, resolve} = waitingForWorkerQueue.shift();\n    let data = src;\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL;\n  // there's no reason to set the workerURL if you're not going to use workers\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n}\n\n// It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({src, uncompressedSize, type, resolve, reject, id: nextId++});\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  const minute = time >> 5 & 0x3f; // 0-59\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n  }\n  // returns a promise that returns a Blob for this entry\n  async blob(type = 'application/octet-stream') {\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  }\n  // returns a promise that returns an ArrayBuffer for this entry\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  }\n  // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  }\n  // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n}\n\n// The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  },\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100 +\n         uint8View[offset + 2] * 0x10000 +\n         uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) +\n         getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n/* eslint-enable no-irregular-whitespace */\n\nconst utf8Decoder = new TextDecoder();\nfunction decodeBuffer(uint8View, isUTF8) {  /* eslint-disable-line no-unused-vars */ /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 0 - End of central directory signature\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);\n    // 4 - Number of this disk\n    const diskNumber = getUint16LE(eocdr, 4);\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = getUint16LE(eocdr, 10);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = getUint32LE(eocdr, 12);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = getUint32LE(eocdr, 16);\n    // 20 - Comment length\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    }\n\n    // 22 - Comment\n    // the encoding is always cp437.\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20);\n\n  // 0 - zip64 end of central dir locator signature\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = getUint64LE(eocdl, 8);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = getUint64LE(zip64Eocdr, 32);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40);\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);\n    // 0 - Central directory file header signature\n    const signature = getUint32LE(buffer, 0);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42),\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes);\n\n    // 46+n - Extra field\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd),\n      });\n      i = dataEnd;\n    }\n\n    // 46+n+m - File comment\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize            === 0xffffffff ||\n        rawEntry.compressedSize              === 0xffffffff ||\n        rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n      if (!zip64ExtraField) {\n        return new Error('expected zip64 extended information extra field');\n      }\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = rawEntry.extraFields.find(e =>\n        e.id === 0x7075 &&\n        e.data.length >= 6 && // too short to be meaningful\n        e.data[0] === 1 &&    // Version       1 byte      version of this extra field, currently 1\n        getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n                                                                   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n                                                                   // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n        // UnicodeName Variable UTF-8 version of the entry File Name\n        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    }\n\n    // validate file size\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n    rawEntries.push(rawEntry);\n  }\n  const zip = {\n    comment,\n    commentBytes,\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e)),\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n  // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n  const totalLength = await reader.getLength();\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = getUint32LE(buffer, 0);\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = getUint16LE(buffer, 26);\n  // 28 - Extra field length (m)\n  const extraFieldLength = getUint16LE(buffer, 28);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n  return {\n    decompress,\n    fileDataStart,\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);\n    // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  }\n  // see comment in readEntryDateAsBlob\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {type});\n  }\n  // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || (source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n}\n\n// If the names are not utf8 you should use unzipitRaw\nasync function unzip(source) {\n  const {zip, entries} = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v])),\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };\n"]},"metadata":{},"sourceType":"module"}