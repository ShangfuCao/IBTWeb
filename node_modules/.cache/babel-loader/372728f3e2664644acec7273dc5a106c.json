{"ast":null,"code":"// @ts-ignore\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\nimport { DoubleSide, MeshLambertMaterial } from 'three';\nimport { IFCLoader } from 'web-ifc-three/IFCLoader';\nimport { IfcComponent } from '../../base-types';\nimport { IfcSelection } from './selection';\nimport { VisibilityManager } from './visibility-manager';\nexport class IfcManager extends IfcComponent {\n  constructor(context) {\n    var _this;\n\n    super(context);\n    _this = this;\n\n    /**\r\n     * Highlights the item pointed by the cursor.\r\n     */\n    this.prePickIfcItem = () => {\n      const found = this.context.castRayIfc();\n\n      if (!found) {\n        this.preselection.removeSelectionOfOtherModel();\n        return;\n      }\n\n      this.preselection.pick(found);\n    };\n    /**\r\n     * Highlights the item pointed by the cursor and gets is properties.\r\n     * @focusSelection If true, animate the perspectiveCamera to focus the current selection\r\n     * @duration The length of the perspectiveCamera animation in seconds\r\n     */\n\n\n    this.pickIfcItem = async function () {\n      let focusSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      let duration = arguments.length > 1 ? arguments[1] : undefined;\n\n      const found = _this.context.castRayIfc();\n\n      if (!found) return null;\n      const result = await _this.selection.pick(found, focusSelection, duration);\n      if (result == null || result.modelID == null || result.id == null) return null;\n      return result;\n    };\n    /**\r\n     * Highlights the item pointed by the cursor and gets is properties, without applying any material to it.\r\n     * @focusSelection If true, animate the perspectiveCamera to focus the current selection\r\n     * @duration The length of the perspectiveCamera animation in seconds\r\n     */\n\n\n    this.highlightIfcItem = async function () {\n      let focusSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      let duration = arguments.length > 1 ? arguments[1] : undefined;\n\n      const found = _this.context.castRayIfc();\n\n      if (!found) return null;\n      const result = await _this.highlight.pick(found, focusSelection, duration);\n      if (result == null || result.modelID == null || result.id == null) return null;\n      return result;\n    };\n    /**\r\n     * Highlights the item with the given ID.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the item.\r\n     */\n\n\n    this.pickIfcItemsByID = function (modelID, ids) {\n      let focusSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let duration = arguments.length > 3 ? arguments[3] : undefined;\n\n      _this.selection.pickByID(modelID, ids, focusSelection, duration);\n    };\n\n    this.prepickIfcItemsByID = function (modelID, ids) {\n      let focusSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let duration = arguments.length > 3 ? arguments[3] : undefined;\n\n      _this.preselection.pickByID(modelID, ids, focusSelection, duration);\n    };\n\n    this.highlightIfcItemsByID = function (modelID, ids) {\n      let focusSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      let duration = arguments.length > 3 ? arguments[3] : undefined;\n\n      _this.highlight.pickByID(modelID, ids, focusSelection, duration);\n    };\n\n    this.unpickIfcItems = () => {\n      this.selection.unpick();\n    };\n\n    this.unPrepickIfcItems = () => {\n      this.preselection.unpick();\n    };\n\n    this.unHighlightIfcItems = () => {\n      this.highlight.unpick();\n    }; // TODO: Move to another file, cleanup\n\n\n    this.newMats = {};\n    this.context = context;\n    this.loader = new IFCLoader();\n    this.setupThreeMeshBVH();\n    this.visibility = new VisibilityManager(this.loader, this.context);\n    this.defSelectMat = this.initializeDefMaterial(0xff33ff, 0.3);\n    this.defPreselectMat = this.initializeDefMaterial(0xffccff, 0.5);\n    this.selectMat = context.options.selectMaterial || this.defSelectMat;\n    this.preselectMat = context.options.preselectMaterial || this.defPreselectMat;\n    this.preselection = new IfcSelection(context, this.loader, this.preselectMat);\n    this.selection = new IfcSelection(context, this.loader, this.selectMat);\n    this.highlight = new IfcSelection(context, this.loader);\n  }\n  /**\r\n   * Loads the given IFC in the current scene.\r\n   * @file IFC as File.\r\n   * @fitToFrame (optional) if true, brings the perspectiveCamera to the loaded IFC.\r\n   * @onError (optional) a callback function to report on loading errors\r\n   */\n\n\n  async loadIfc(file) {\n    let fitToFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let onError = arguments.length > 2 ? arguments[2] : undefined;\n    const url = URL.createObjectURL(file);\n    return this.loadIfcUrl(url, fitToFrame, undefined, onError);\n  }\n  /**\r\n   * Loads the given IFC in the current scene.\r\n   * @file IFC as URL.\r\n   * @fitToFrame (optional) if true, brings the perspectiveCamera to the loaded IFC.\r\n   * @onProgress (optional) a callback function to report on downloading progress\r\n   * @onError (optional) a callback function to report on loading errors\r\n   */\n\n\n  async loadIfcUrl(url) {\n    let fitToFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let onProgress = arguments.length > 2 ? arguments[2] : undefined;\n    let onError = arguments.length > 3 ? arguments[3] : undefined;\n\n    try {\n      const ifcModel = await this.loader.loadAsync(url, onProgress);\n      this.addIfcModel(ifcModel.mesh);\n      if (fitToFrame) this.context.fitToFrame();\n      return ifcModel;\n    } catch (err) {\n      console.error('Error loading IFC.');\n      console.error(err);\n      if (onError) onError(err);\n      return null;\n    }\n  }\n  /**\r\n   * Sets the relative path of web-ifc.wasm file in the project.\r\n   * Beware: you **must** serve this file in your page; this means\r\n   * that you have to copy this files from *node_modules/web-ifc*\r\n   * to your deployment directory.\r\n   *\r\n   * If you don't use this methods,\r\n   * IFC.js assumes that you are serving it in the root directory.\r\n   *\r\n   * Example if web-ifc.wasm is in dist/wasmDir:\r\n   * `ifcLoader.setWasmPath(\"dist/wasmDir/\");`\r\n   *\r\n   * @path Relative path to web-ifc.wasm.\r\n   */\n\n\n  setWasmPath(path) {\n    this.loader.ifcManager.setWasmPath(path);\n  }\n  /**\r\n   * Applies a configuration for [web-ifc](https://ifcjs.github.io/info/docs/Guide/web-ifc/Introduction).\r\n   */\n\n\n  applyWebIfcConfig(settings) {\n    this.loader.ifcManager.applyWebIfcConfig(settings);\n  }\n  /**\r\n   * Gets the spatial structure of the specified model.\r\n   * @modelID ID of the IFC model.\r\n   */\n\n\n  getSpatialStructure(modelID, includeProperties) {\n    return this.loader.ifcManager.getSpatialStructure(modelID, includeProperties);\n  }\n  /**\r\n   * Gets the properties of the specified item.\r\n   * @modelID ID of the IFC model.\r\n   * @id Express ID of the item.\r\n   * @indirect If true, also returns psets, qsets and type properties.\r\n   * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n   */\n\n\n  async getProperties(modelID, id, indirect, recursive) {\n    if (modelID == null || id == null) return null;\n    const props = await this.loader.ifcManager.getItemProperties(modelID, id, recursive);\n\n    if (indirect) {\n      props.psets = await this.loader.ifcManager.getPropertySets(modelID, id, recursive);\n      props.mats = await this.loader.ifcManager.getMaterialsProperties(modelID, id, recursive);\n      props.type = await this.loader.ifcManager.getTypeProperties(modelID, id, recursive);\n    }\n\n    return props;\n  }\n  /**\r\n   * Gets the ID of the model pointed by the cursor.\r\n   */\n\n\n  getModelID() {\n    const found = this.context.castRayIfc();\n    if (!found) return null;\n    const mesh = found.object;\n    if (!mesh || mesh.modelID === undefined || mesh.modelID === null) return null;\n    return mesh.modelID;\n  }\n  /**\r\n   * Gets all the items of the specified type in the specified IFC model.\r\n   * @modelID ID of the IFC model.\r\n   * @type type of element. You can import the type from web-ifc.\r\n   * @verbose If true, also gets the properties for all the elements.\r\n   */\n\n\n  getAllItemsOfType(modelID, type) {\n    let verbose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return this.loader.ifcManager.getAllItemsOfType(modelID, type, verbose);\n  }\n  /**\r\n   * Hides the selected items in the specified model\r\n   * @modelID ID of the IFC model.\r\n   * @ids Express ID of the elements.\r\n   */\n\n\n  hideItems(modelID, ids) {\n    this.loader.ifcManager.hideItems(modelID, ids);\n  }\n  /**\r\n   * Hides all the items of the specified model\r\n   * @modelID ID of the IFC model.\r\n   */\n\n\n  hideAllItems(modelID) {\n    this.loader.ifcManager.hideAllItems(modelID);\n  }\n  /**\r\n   * Shows all the items of the specified model\r\n   * @modelID ID of the IFC model.\r\n   * @ids Express ID of the elements.\r\n   */\n\n\n  showItems(modelID, ids) {\n    this.loader.ifcManager.showItems(modelID, ids);\n  }\n  /**\r\n   * Shows all the items of the specified model\r\n   * @modelID ID of the IFC model.\r\n   */\n\n\n  showAllItems(modelID) {\n    this.loader.ifcManager.showAllItems(modelID);\n  }\n  /**\r\n   * Makes an IFC model translucent\r\n   * @modelID ID of the IFC model.\r\n   * @translucent wether to activate or deactivate the translucency.\r\n   * @opacity the opacity of the translucent material.\r\n   * @selectable wether the translucent models are selectable with the mouse.\r\n   */\n\n\n  setModelTranslucency(modelID, translucent) {\n    let opacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.2;\n    let selectable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const model = this.context.items.ifcModels.find(model => model.modelID === modelID);\n    if (!model) return;\n\n    if (Array.isArray(model.material)) {\n      model.material.forEach(material => {\n        if (material.userData.opacity === undefined) {\n          material.userData = {\n            transparent: material.transparent,\n            opacity: material.opacity\n          };\n        }\n      });\n      if (!this.newMats[modelID]) this.newMats[modelID] = model.material.map(mat => mat.clone());\n      const newMats = this.newMats[modelID];\n      newMats.forEach(mat => {\n        mat.opacity = translucent ? opacity : mat.userData.opacity;\n        mat.transparent = translucent ? true : mat.userData.transparent;\n      });\n      model.material = newMats;\n    }\n\n    if (translucent && !selectable) {\n      const index = this.context.items.pickableIfcModels.indexOf(model);\n      this.context.items.pickableIfcModels.splice(index, 1);\n    } else if (!this.context.items.pickableIfcModels.includes(model)) {\n      this.context.items.pickableIfcModels.push(model);\n    }\n  }\n\n  addIfcModel(ifcMesh) {\n    this.context.items.ifcModels.push(ifcMesh);\n    this.context.items.pickableIfcModels.push(ifcMesh);\n    this.context.getScene().add(ifcMesh);\n  }\n\n  setupThreeMeshBVH() {\n    this.loader.ifcManager.setupThreeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast);\n  }\n\n  initializeDefMaterial(color, opacity) {\n    return new MeshLambertMaterial({\n      color,\n      opacity,\n      transparent: true,\n      depthTest: false,\n      side: DoubleSide\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/components/ifc/ifc-manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @ts-ignore\r\nimport { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';\r\nimport { DoubleSide, MeshLambertMaterial } from 'three';\r\nimport { IFCLoader } from 'web-ifc-three/IFCLoader';\r\nimport { IfcComponent } from '../../base-types';\r\nimport { IfcSelection } from './selection';\r\nimport { VisibilityManager } from './visibility-manager';\r\nexport class IfcManager extends IfcComponent {\r\n    constructor(context) {\r\n        super(context);\r\n        /**\r\n         * Highlights the item pointed by the cursor.\r\n         */\r\n        this.prePickIfcItem = () => {\r\n            const found = this.context.castRayIfc();\r\n            if (!found) {\r\n                this.preselection.removeSelectionOfOtherModel();\r\n                return;\r\n            }\r\n            this.preselection.pick(found);\r\n        };\r\n        /**\r\n         * Highlights the item pointed by the cursor and gets is properties.\r\n         * @focusSelection If true, animate the perspectiveCamera to focus the current selection\r\n         * @duration The length of the perspectiveCamera animation in seconds\r\n         */\r\n        this.pickIfcItem = async (focusSelection = false, duration) => {\r\n            const found = this.context.castRayIfc();\r\n            if (!found)\r\n                return null;\r\n            const result = await this.selection.pick(found, focusSelection, duration);\r\n            if (result == null || result.modelID == null || result.id == null)\r\n                return null;\r\n            return result;\r\n        };\r\n        /**\r\n         * Highlights the item pointed by the cursor and gets is properties, without applying any material to it.\r\n         * @focusSelection If true, animate the perspectiveCamera to focus the current selection\r\n         * @duration The length of the perspectiveCamera animation in seconds\r\n         */\r\n        this.highlightIfcItem = async (focusSelection = false, duration) => {\r\n            const found = this.context.castRayIfc();\r\n            if (!found)\r\n                return null;\r\n            const result = await this.highlight.pick(found, focusSelection, duration);\r\n            if (result == null || result.modelID == null || result.id == null)\r\n                return null;\r\n            return result;\r\n        };\r\n        /**\r\n         * Highlights the item with the given ID.\r\n         * @modelID ID of the IFC model.\r\n         * @id Express ID of the item.\r\n         */\r\n        this.pickIfcItemsByID = (modelID, ids, focusSelection = false, duration) => {\r\n            this.selection.pickByID(modelID, ids, focusSelection, duration);\r\n        };\r\n        this.prepickIfcItemsByID = (modelID, ids, focusSelection = false, duration) => {\r\n            this.preselection.pickByID(modelID, ids, focusSelection, duration);\r\n        };\r\n        this.highlightIfcItemsByID = (modelID, ids, focusSelection = false, duration) => {\r\n            this.highlight.pickByID(modelID, ids, focusSelection, duration);\r\n        };\r\n        this.unpickIfcItems = () => {\r\n            this.selection.unpick();\r\n        };\r\n        this.unPrepickIfcItems = () => {\r\n            this.preselection.unpick();\r\n        };\r\n        this.unHighlightIfcItems = () => {\r\n            this.highlight.unpick();\r\n        };\r\n        // TODO: Move to another file, cleanup\r\n        this.newMats = {};\r\n        this.context = context;\r\n        this.loader = new IFCLoader();\r\n        this.setupThreeMeshBVH();\r\n        this.visibility = new VisibilityManager(this.loader, this.context);\r\n        this.defSelectMat = this.initializeDefMaterial(0xff33ff, 0.3);\r\n        this.defPreselectMat = this.initializeDefMaterial(0xffccff, 0.5);\r\n        this.selectMat = context.options.selectMaterial || this.defSelectMat;\r\n        this.preselectMat = context.options.preselectMaterial || this.defPreselectMat;\r\n        this.preselection = new IfcSelection(context, this.loader, this.preselectMat);\r\n        this.selection = new IfcSelection(context, this.loader, this.selectMat);\r\n        this.highlight = new IfcSelection(context, this.loader);\r\n    }\r\n    /**\r\n     * Loads the given IFC in the current scene.\r\n     * @file IFC as File.\r\n     * @fitToFrame (optional) if true, brings the perspectiveCamera to the loaded IFC.\r\n     * @onError (optional) a callback function to report on loading errors\r\n     */\r\n    async loadIfc(file, fitToFrame = false, onError) {\r\n        const url = URL.createObjectURL(file);\r\n        return this.loadIfcUrl(url, fitToFrame, undefined, onError);\r\n    }\r\n    /**\r\n     * Loads the given IFC in the current scene.\r\n     * @file IFC as URL.\r\n     * @fitToFrame (optional) if true, brings the perspectiveCamera to the loaded IFC.\r\n     * @onProgress (optional) a callback function to report on downloading progress\r\n     * @onError (optional) a callback function to report on loading errors\r\n     */\r\n    async loadIfcUrl(url, fitToFrame = false, onProgress, onError) {\r\n        try {\r\n            const ifcModel = (await this.loader.loadAsync(url, onProgress));\r\n            this.addIfcModel(ifcModel.mesh);\r\n            if (fitToFrame)\r\n                this.context.fitToFrame();\r\n            return ifcModel;\r\n        }\r\n        catch (err) {\r\n            console.error('Error loading IFC.');\r\n            console.error(err);\r\n            if (onError)\r\n                onError(err);\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the relative path of web-ifc.wasm file in the project.\r\n     * Beware: you **must** serve this file in your page; this means\r\n     * that you have to copy this files from *node_modules/web-ifc*\r\n     * to your deployment directory.\r\n     *\r\n     * If you don't use this methods,\r\n     * IFC.js assumes that you are serving it in the root directory.\r\n     *\r\n     * Example if web-ifc.wasm is in dist/wasmDir:\r\n     * `ifcLoader.setWasmPath(\"dist/wasmDir/\");`\r\n     *\r\n     * @path Relative path to web-ifc.wasm.\r\n     */\r\n    setWasmPath(path) {\r\n        this.loader.ifcManager.setWasmPath(path);\r\n    }\r\n    /**\r\n     * Applies a configuration for [web-ifc](https://ifcjs.github.io/info/docs/Guide/web-ifc/Introduction).\r\n     */\r\n    applyWebIfcConfig(settings) {\r\n        this.loader.ifcManager.applyWebIfcConfig(settings);\r\n    }\r\n    /**\r\n     * Gets the spatial structure of the specified model.\r\n     * @modelID ID of the IFC model.\r\n     */\r\n    getSpatialStructure(modelID, includeProperties) {\r\n        return this.loader.ifcManager.getSpatialStructure(modelID, includeProperties);\r\n    }\r\n    /**\r\n     * Gets the properties of the specified item.\r\n     * @modelID ID of the IFC model.\r\n     * @id Express ID of the item.\r\n     * @indirect If true, also returns psets, qsets and type properties.\r\n     * @recursive If true, this gets the native properties of the referenced elements recursively.\r\n     */\r\n    async getProperties(modelID, id, indirect, recursive) {\r\n        if (modelID == null || id == null)\r\n            return null;\r\n        const props = await this.loader.ifcManager.getItemProperties(modelID, id, recursive);\r\n        if (indirect) {\r\n            props.psets = await this.loader.ifcManager.getPropertySets(modelID, id, recursive);\r\n            props.mats = await this.loader.ifcManager.getMaterialsProperties(modelID, id, recursive);\r\n            props.type = await this.loader.ifcManager.getTypeProperties(modelID, id, recursive);\r\n        }\r\n        return props;\r\n    }\r\n    /**\r\n     * Gets the ID of the model pointed by the cursor.\r\n     */\r\n    getModelID() {\r\n        const found = this.context.castRayIfc();\r\n        if (!found)\r\n            return null;\r\n        const mesh = found.object;\r\n        if (!mesh || mesh.modelID === undefined || mesh.modelID === null)\r\n            return null;\r\n        return mesh.modelID;\r\n    }\r\n    /**\r\n     * Gets all the items of the specified type in the specified IFC model.\r\n     * @modelID ID of the IFC model.\r\n     * @type type of element. You can import the type from web-ifc.\r\n     * @verbose If true, also gets the properties for all the elements.\r\n     */\r\n    getAllItemsOfType(modelID, type, verbose = false) {\r\n        return this.loader.ifcManager.getAllItemsOfType(modelID, type, verbose);\r\n    }\r\n    /**\r\n     * Hides the selected items in the specified model\r\n     * @modelID ID of the IFC model.\r\n     * @ids Express ID of the elements.\r\n     */\r\n    hideItems(modelID, ids) {\r\n        this.loader.ifcManager.hideItems(modelID, ids);\r\n    }\r\n    /**\r\n     * Hides all the items of the specified model\r\n     * @modelID ID of the IFC model.\r\n     */\r\n    hideAllItems(modelID) {\r\n        this.loader.ifcManager.hideAllItems(modelID);\r\n    }\r\n    /**\r\n     * Shows all the items of the specified model\r\n     * @modelID ID of the IFC model.\r\n     * @ids Express ID of the elements.\r\n     */\r\n    showItems(modelID, ids) {\r\n        this.loader.ifcManager.showItems(modelID, ids);\r\n    }\r\n    /**\r\n     * Shows all the items of the specified model\r\n     * @modelID ID of the IFC model.\r\n     */\r\n    showAllItems(modelID) {\r\n        this.loader.ifcManager.showAllItems(modelID);\r\n    }\r\n    /**\r\n     * Makes an IFC model translucent\r\n     * @modelID ID of the IFC model.\r\n     * @translucent wether to activate or deactivate the translucency.\r\n     * @opacity the opacity of the translucent material.\r\n     * @selectable wether the translucent models are selectable with the mouse.\r\n     */\r\n    setModelTranslucency(modelID, translucent, opacity = 0.2, selectable = false) {\r\n        const model = this.context.items.ifcModels.find((model) => model.modelID === modelID);\r\n        if (!model)\r\n            return;\r\n        if (Array.isArray(model.material)) {\r\n            model.material.forEach((material) => {\r\n                if (material.userData.opacity === undefined) {\r\n                    material.userData = { transparent: material.transparent, opacity: material.opacity };\r\n                }\r\n            });\r\n            if (!this.newMats[modelID])\r\n                this.newMats[modelID] = model.material.map((mat) => mat.clone());\r\n            const newMats = this.newMats[modelID];\r\n            newMats.forEach((mat) => {\r\n                mat.opacity = translucent ? opacity : mat.userData.opacity;\r\n                mat.transparent = translucent ? true : mat.userData.transparent;\r\n            });\r\n            model.material = newMats;\r\n        }\r\n        if (translucent && !selectable) {\r\n            const index = this.context.items.pickableIfcModels.indexOf(model);\r\n            this.context.items.pickableIfcModels.splice(index, 1);\r\n        }\r\n        else if (!this.context.items.pickableIfcModels.includes(model)) {\r\n            this.context.items.pickableIfcModels.push(model);\r\n        }\r\n    }\r\n    addIfcModel(ifcMesh) {\r\n        this.context.items.ifcModels.push(ifcMesh);\r\n        this.context.items.pickableIfcModels.push(ifcMesh);\r\n        this.context.getScene().add(ifcMesh);\r\n    }\r\n    setupThreeMeshBVH() {\r\n        this.loader.ifcManager.setupThreeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast);\r\n    }\r\n    initializeDefMaterial(color, opacity) {\r\n        return new MeshLambertMaterial({\r\n            color,\r\n            opacity,\r\n            transparent: true,\r\n            depthTest: false,\r\n            side: DoubleSide\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=ifc-manager.js.map"]},"metadata":{},"sourceType":"module"}